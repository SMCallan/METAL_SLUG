<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metal Slug Lite - Sprite Player</title>
    <style>
        body {
            font-family: 'Press Start 2P', cursive, sans-serif;
            background-color: #1a1a1a;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding-top: 20px;
            height: 100vh;
            overflow: hidden;
        }

        h1 {
            color: #FFD700;
            text-shadow: 2px 2px #FF0000, -2px -2px #0000FF;
            font-size: 1.8em;
            margin-bottom: 15px;
        }

        canvas {
            border: 4px solid #fff;
            background-color: #000;
            display: block;
            box-shadow: 0 0 15px #fff;
        }

        .controls-info {
            margin-top: 15px;
            font-size: 0.9em;
            color: #ccc;
            background-color: rgba(0,0,0,0.5);
            padding: 8px 12px;
            border-radius: 5px;
        }
         #loadingMessage {
            color: yellow;
            font-style: italic;
        }
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    </style>
</head>
<body>
    <h1>Metal Slug Lite (Sprite Player)</h1>
    <canvas id="gameCanvas"></canvas>
    <div class="controls-info">
        <p>Controls: Arrow Keys (Move/Jump), Spacebar (Shoot)</p>
        <p id="loadingMessage">Loading assets...</p>
    </div>

    <script>
        // --- Utility Functions ---
        function AABBCollision(rect1, rect2) {
            return (
                rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y
            );
        }

        // --- Asset Manager ---
        const assetManager = {
            images: {},
            totalAssetsToLoad: 0,
            loadedAssets: 0,
            _promises: [], // Internal store for promises

            loadImage(name, src) {
                this.totalAssetsToLoad++;
                const img = new Image();
                const promise = new Promise((resolve, reject) => {
                    img.onload = () => {
                        this.images[name] = img;
                        this.loadedAssets++;
                        console.log(`Loaded image: ${name}`);
                        resolve(img);
                    };
                    img.onerror = (err) => {
                        console.error(`Failed to load image: ${name} from ${src}`, err);
                        // Still resolve to not block Promise.all, but image will be undefined or broken
                        // The game logic should handle missing images gracefully (e.g. fallback drawing)
                        this.loadedAssets++; // Count as "attempted" to finish loading sequence
                        reject(new Error(`Failed to load image: ${name}`));
                    };
                });
                img.src = src;
                this._promises.push(promise);
                return promise;
            },

            async loadAll() {
                const loadingMessageEl = document.getElementById('loadingMessage');
                if (this.totalAssetsToLoad === 0) {
                    if(loadingMessageEl) loadingMessageEl.style.display = 'none';
                    return Promise.resolve();
                }
                
                const progressInterval = setInterval(() => {
                    if (loadingMessageEl) {
                         loadingMessageEl.textContent = `Loading assets... (${this.loadedAssets}/${this.totalAssetsToLoad})`;
                    }
                }, 100);

                return Promise.all(this._promises.map(p => p.catch(e => e))) // Handle individual promise rejections
                    .then((results) => {
                        const successfulLoads = results.filter(r => !(r instanceof Error));
                        console.log(`All assets attempted. ${successfulLoads.length}/${this.totalAssetsToLoad} loaded successfully.`);
                        if(loadingMessageEl) loadingMessageEl.style.display = 'none';
                    })
                    .catch((error) => { // Should not be reached if individual errors are caught above
                        console.error("Unexpected error during asset loading process:", error);
                         if(loadingMessageEl) loadingMessageEl.textContent = 'Critical error loading assets!';
                    })
                    .finally(() => {
                        clearInterval(progressInterval);
                        // Clear promises for potential re-runs or further asset loading, if needed.
                        this._promises = []; 
                        // Don't reset counters here if you might add more assets dynamically and call loadAll again.
                        // For this game, it's a one-time load, so it's less critical.
                    });
            },

            getImage(name) {
                const img = this.images[name];
                if (!img) {
                    // console.warn(`AssetManager: Image "${name}" not found or not loaded.`);
                } else if (img.complete && img.naturalHeight === 0) {
                    // console.warn(`AssetManager: Image "${name}" loaded but seems broken (naturalHeight is 0).`);
                }
                return img;
            }
        };


        // --- Input Handler ---
        class InputHandler {
            constructor() {
                this.keys = new Set();
                // Removed shootPressedThisFrame as Player's shootCooldown handles fire rate
                window.addEventListener('keydown', (e) => {
                    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', ' '].includes(e.key)) {
                        e.preventDefault();
                        this.keys.add(e.key === ' ' ? 'Space' : e.key);
                    }
                });
                window.addEventListener('keyup', (e) => {
                    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', ' '].includes(e.key)) {
                        e.preventDefault();
                        this.keys.delete(e.key === ' ' ? 'Space' : e.key);
                    }
                });
            }
            isKeyPressed(key) { return this.keys.has(key); }
            consumeShoot() { return this.keys.has('Space'); } // Allows holding space for continuous fire
        }

        // --- Projectile Class ---
        class Projectile {
            constructor(x, y, direction, gameWidth) {
                this.x = x; this.y = y; this.direction = direction; this.gameWidth = gameWidth;
                this.width = 10; this.height = 5; this.speed = 9;
                this.color = '#FFEB3B'; this.active = true;
            }
            update() {
                this.x += (this.direction === 'right' ? this.speed : -this.speed);
                if (this.x < -this.width || this.x > this.gameWidth) this.active = false;
            }
            draw(ctx) { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); }
            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
        }

        // --- Enemy Class ---
        class Enemy {
             constructor(x, y, gameWidth) {
                this.x = x; this.y = y; this.gameWidth = gameWidth;
                this.width = 28; this.height = 45;
                this.color = '#F44336'; this.speed = (Math.random() * 1.5 + 0.8);
                this.active = true; this.direction = (x > gameWidth / 2) ? -1 : 1;
                this.health = 1;
            }
            update() {
                this.x += this.speed * this.direction;
                if ((this.direction === -1 && this.x < 0 - this.width) || (this.direction === 1 && this.x > this.gameWidth)) {
                    this.active = false;
                }
            }
            draw(ctx) {
                ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = 'white';
                const eyeX = this.direction === 'right' ? this.x + this.width - 8 : this.x + 2;
                ctx.fillRect(eyeX, this.y + 8, 6, 6);
            }
            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
            takeDamage() { if (--this.health <= 0) this.active = false; }
        }

        // --- Player Class ---
        class Player {
            constructor(gameWidth, gameHeight) {
                this.gameWidth = gameWidth; this.gameHeight = gameHeight;
                // IMPORTANT: Adjust these width/height values to your sprite's desired size in the game
                this.width = 48; // Example: Adjust to fit MGSprite.png
                this.height = 78; // Example: Adjust to fit MGSprite.png
                this.x = 50; this.y = gameHeight - this.height - 10; // Ground level
                this.fallbackColor = '#4CAF50';
                this.speed = 4.5; this.projectiles = [];
                this.velocityY = 0; this.gravity = 0.7; this.jumpStrength = -16;
                this.onGround = true; this.facingDirection = 'right';
                this.shootCooldown = 0; this.shootCooldownTime = 180;
                this.health = 3; this.isInvincible = false;
                this.invincibilityDuration = 1500; this.invincibilityTimer = 0;

                // Get pre-loaded sprites
                this.spriteRight = assetManager.getImage('playerRight');
                this.spriteLeft = assetManager.getImage('playerLeft');
            }

            update(input, deltaTime) {
                if (input.isKeyPressed('ArrowLeft')) { this.x -= this.speed; this.facingDirection = 'left'; }
                if (input.isKeyPressed('ArrowRight')) { this.x += this.speed; this.facingDirection = 'right'; }
                if (input.isKeyPressed('ArrowUp') && this.onGround) { this.velocityY = this.jumpStrength; this.onGround = false; }

                this.y += this.velocityY; this.velocityY += this.gravity;
                const groundLevel = this.gameHeight - this.height - 10;
                if (this.y >= groundLevel) { this.y = groundLevel; this.velocityY = 0; this.onGround = true; }

                if (this.x < 0) this.x = 0;
                if (this.x + this.width > this.gameWidth) this.x = this.gameWidth - this.width;

                if (this.shootCooldown > 0) this.shootCooldown -= deltaTime;
                if (input.consumeShoot() && this.shootCooldown <= 0) { this.shoot(); this.shootCooldown = this.shootCooldownTime; }

                this.projectiles.forEach(p => p.update());
                this.projectiles = this.projectiles.filter(p => p.active);

                if (this.isInvincible) {
                    this.invincibilityTimer -= deltaTime;
                    if (this.invincibilityTimer <= 0) this.isInvincible = false;
                }
            }

            shoot() {
                const projX = this.facingDirection === 'right' ? this.x + this.width : this.x - 10; // 10 = projectile.width
                const projY = this.y + this.height / 2 - 2.5; // 2.5 = projectile.height / 2
                this.projectiles.push(new Projectile(projX, projY, this.facingDirection, this.gameWidth));
            }

            draw(ctx) {
                const currentSprite = this.facingDirection === 'right' ? this.spriteRight : this.spriteLeft;
                
                if (this.isInvincible) {
                    ctx.globalAlpha = (Math.floor(Date.now() / 100) % 2 === 0) ? 0.6 : 1.0;
                }

                if (currentSprite && currentSprite.complete && currentSprite.naturalHeight !== 0) {
                    ctx.drawImage(currentSprite, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = this.fallbackColor; // Fallback if sprite not loaded/broken
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    // Log only once or less frequently if image is persistently missing
                    if (!this._spriteMissingLogged && (!currentSprite || !currentSprite.complete)) {
                        console.warn(`Player sprite for direction "${this.facingDirection}" is missing or not loaded. Drawing fallback.`);
                        this._spriteMissingLogged = true; // Prevent flooding console
                    }
                }
                ctx.globalAlpha = 1.0; // Reset alpha

                this.projectiles.forEach(p => p.draw(ctx));
            }

            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
            takeDamage() {
                if (this.isInvincible) return false;
                this.health--;
                if (this.health > 0) { this.isInvincible = true; this.invincibilityTimer = this.invincibilityDuration; }
                return true;
            }
        }

        // --- Game Class ---
        class Game {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                if (!this.canvas || !this.ctx) {
                    alert("Error: Canvas not supported or found. Game cannot start.");
                    throw new Error("Canvas init failed");
                }
                this.canvas.width = 800; this.canvas.height = 450;

                this.inputHandler = new InputHandler();
                this.player = null; // Will be initialized after assets load
                this.enemies = []; this.score = 0; this.lastTime = 0;
                this.animationFrameId = null; this.isGameOver = false;
                this.enemySpawnTimer = 0; this.enemySpawnInterval = 2500;
                this.gameLoop = this.gameLoop.bind(this);
            }

            spawnEnemy() {
                const groundY = this.canvas.height - 45 - 10; // enemy height 45
                const spawnX = Math.random() < 0.5 ? -30 - Math.random() * 50 : this.canvas.width + Math.random() * 50;
                this.enemies.push(new Enemy(spawnX, groundY, this.canvas.width));
            }
            
            update(deltaTime) {
                if (this.isGameOver || !this.player) return;
                this.player.update(this.inputHandler, deltaTime);
                this.enemies.forEach(enemy => enemy.update());

                // Projectile vs Enemy collision
                this.player.projectiles.forEach(proj => {
                    this.enemies.forEach(enemy => {
                        if (proj.active && enemy.active && AABBCollision(proj.getRect(), enemy.getRect())) {
                            proj.active = false; enemy.takeDamage();
                            if (!enemy.active) this.score += 100;
                        }
                    });
                });
                // Player vs Enemy collision
                this.enemies.forEach(enemy => {
                    if (enemy.active && AABBCollision(this.player.getRect(), enemy.getRect())) {
                        if (this.player.takeDamage() && this.player.health <= 0) this.gameOver();
                    }
                });
                this.player.projectiles = this.player.projectiles.filter(p => p.active);
                this.enemies = this.enemies.filter(e => e.active);

                this.enemySpawnTimer += deltaTime;
                if (this.enemySpawnTimer >= this.enemySpawnInterval) {
                    if (this.enemies.length < 8) this.spawnEnemy();
                    this.enemySpawnTimer = 0;
                    if (this.enemySpawnInterval > 800) this.enemySpawnInterval -= 20;
                }
            }

            drawPlayerHealth() {
                if (!this.player) return;
                this.ctx.fillStyle = 'white'; this.ctx.font = '18px "Press Start 2P"';
                this.ctx.textAlign = 'right';
                this.ctx.fillText(`Health: ${"❤️".repeat(this.player.health)}`, this.canvas.width - 20, 30);
            }
            
            draw() {
                this.ctx.fillStyle = '#2c3e50'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#7f8c8d'; this.ctx.fillRect(0, this.canvas.height - 10, this.canvas.width, 10);

                if (this.player) this.player.draw(this.ctx);
                else { // Fallback if player isn't loaded yet
                    this.ctx.fillStyle = 'white'; this.ctx.font = '20px "Press Start 2P"';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Initializing Player...', this.canvas.width / 2, this.canvas.height / 2);
                }
                this.enemies.forEach(enemy => enemy.draw(this.ctx));

                this.ctx.fillStyle = 'white'; this.ctx.font = '20px "Press Start 2P"';
                this.ctx.textAlign = 'left'; this.ctx.fillText(`Score: ${this.score}`, 20, 30);
                this.drawPlayerHealth();

                if (this.isGameOver) this.drawGameOverScreen();
            }

            drawGameOverScreen() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.font = '48px "Press Start 2P"'; this.ctx.fillStyle = '#E74C3C';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 40);
                this.ctx.font = '24px "Press Start 2P"'; this.ctx.fillStyle = 'white';
                this.ctx.fillText(`Final Score: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 20);
                this.ctx.fillText('Refresh to Play Again', this.canvas.width / 2, this.canvas.height / 2 + 70);
            }
            gameOver() { this.isGameOver = true; }

            gameLoop(timestamp) {
                const deltaTime = timestamp - (this.lastTime || timestamp); // Handle first frame
                this.lastTime = timestamp;

                if (!this.isGameOver && this.player) this.update(deltaTime);
                this.draw();
                this.animationFrameId = requestAnimationFrame(this.gameLoop);
            }

            async initAndStart() {
                // 1. Load assets
                assetManager.loadImage('playerLeft', 'MGSpriteleft.png');
                assetManager.loadImage('playerRight', 'MGSpriteright.png');
                // Add future assets here: assetManager.loadImage('enemy1', 'enemy1.png');

                await assetManager.loadAll(); // Wait for all images

                // 2. Initialize game objects that depend on assets
                this.player = new Player(this.canvas.width, this.canvas.height);

                // 3. Reset game state & start loop
                this.isGameOver = false; this.score = 0;
                this.enemies = []; this.enemySpawnTimer = 0;
                this.enemySpawnInterval = 2500;
                this.spawnEnemy(); // Initial enemy

                if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
                this.lastTime = 0; // Reset for accurate deltaTime on new start
                this.animationFrameId = requestAnimationFrame(this.gameLoop);
            }
        }

        // --- Initialize Game ---
        window.addEventListener('DOMContentLoaded', () => {
            try {
                const game = new Game('gameCanvas');
                game.initAndStart().catch(err => {
                    console.error("Failed to initialize and start game:", err);
                    const loadingMessageEl = document.getElementById('loadingMessage');
                    if (loadingMessageEl) loadingMessageEl.textContent = "Error starting game. Check console.";
                });
            } catch (e) {
                console.error("Error creating Game instance:", e);
                alert("Critical error: Game could not be created. Check console.");
                 const loadingMessageEl = document.getElementById('loadingMessage');
                 if(loadingMessageEl) loadingMessageEl.textContent = "Critical error creating game instance.";
            }
        });
    </script>
</body>
</html>
