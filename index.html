<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metal Lugs - Improved</title>
    <style>
        body {
            font-family: 'Press Start 2P', cursive, sans-serif;
            background-color: #1a1a1a;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding-top: 10px; /* Space for the title image */
            height: 100vh;
            overflow: hidden;
        }
        #gameTitleImage {
            display: block;
            margin: 0 auto 10px auto; /* Centers the image and adds bottom margin */
            max-width: 90%;           /* Ensures responsiveness on smaller screens */
            width: 350px;             /* Desired width for the title image */
            height: auto;             /* Maintains aspect ratio */
        }
        canvas {
            border: 4px solid #fff;
            background-color: #000;
            display: block;
            box-shadow: 0 0 15px #fff;
            cursor: default;          /* Default cursor for the game canvas */
        }
        canvas.clickable {
            cursor: pointer;          /* Pointer cursor when hovering over interactive elements */
        }
        .controls-info {
            margin-top: 10px;
            font-size: 0.8em;
            color: #ccc;
            background-color: rgba(0,0,0,0.5);
            padding: 6px 10px;
            border-radius: 5px;
        }
         #loadingMessage {
            color: yellow;
            font-style: italic;
        }
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    </style>
</head>
<body>
    <img id="gameTitleImage" src="METALLUGS.png" alt="Metal Lugs Title">

    <canvas id="gameCanvas"></canvas>
    <div class="controls-info">
        <p>Controls: Arrow Keys (Move/Jump/Duck), Spacebar (Shoot)</p>
        <p id="loadingMessage">LOADING ASSETS...</p>
    </div>

    <script>
        console.log("Script execution started.");

        // --- Game Constants (Safer Improvements) ---
        const CANVAS_WIDTH = 960;
        const CANVAS_HEIGHT = 540;
        const GROUND_Y_OFFSET = 10; // How thick the ground visually is

        const PLAYER_CONSTANTS = {
            WIDTH: 60,
            HEIGHT: 98,
            SPEED: 5,
            GRAVITY: 0.75,
            JUMP_STRENGTH: -17,
            SHOOT_COOLDOWN_TIME: 180, //ms
            HEALTH: 3,
            INVINCIBILITY_DURATION: 1500, //ms
            WALK_ANIMATION_DELAY: 150, //ms
            BULLET_Y_OFFSET_DIVISOR: 2, // For projY = this.y + this.height / DIVISOR - (bulletHeight / 2)
            BULLET_HEIGHT: 5 // Assuming Projectile height
        };

        const ENEMY_CONSTANTS = {
            GROUND: { WIDTH: 50, HEIGHT: 75, MIN_SPEED: 0.5, MAX_SPEED: 1.0, SCORE: 50, ANIM_DELAY: 200 }, // Added ANIM_DELAY
            FLYING: { BASE_WIDTH: 48, BASE_HEIGHT: 48, SCALE_FACTOR: 1.07, MIN_SPEED: 1.0, MAX_SPEED: 1.5, SCORE: 75, ANIM_DELAY: 120 },
            EXPLOSION_DURATION: 300 //ms
        };

        const BOSS_CONSTANTS = {
            WIDTH: 180, HEIGHT: 150, SPEED: 1, HEALTH: 9,
            IDLE_DURATION: 2500, FIRING_DURATION: 2000, FIRE_COOLDOWN: 700,
            SCORE_HIT: 25, SCORE_DEFEAT: 1000, EXPLOSION_DURATION: 1000
        };

        const PROJECTILE_CONSTANTS = {
            PLAYER: { WIDTH: 10, HEIGHT: PLAYER_CONSTANTS.BULLET_HEIGHT, SPEED: 9, COLOR: '#FFEB3B' },
            BOSS:   { WIDTH: 20, HEIGHT: 10, SPEED: 4, COLOR: '#FF6347' }
        };


        // --- Utility Functions ---
        function AABBCollision(rect1, rect2) {
            return (
                rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y
            );
        }

        // --- Asset Manager ---
        const assetManager = {
            images: {},
            totalAssetsToLoad: 0,
            loadedAssets: 0,
            _promises: [],
            _assetsToLoadConfig: [ // Data-driven asset loading
                { name: 'MGSpriteleft', src: 'MGSpriteleft.png' }, { name: 'MGSpriteright', src: 'MGSpriteright.png' },
                { name: 'MGSpriteleft2', src: 'MGSpriteleft2.png' }, { name: 'MGSpriteright2', src: 'MGSpriteright2.png' },
                { name: 'JumpLeft', src: 'JumpLeft.png' }, { name: 'JumpRight', src: 'JumpRight.png' },
                { name: 'DuckLeft', src: 'DuckLeft.png' }, { name: 'DuckRight', src: 'DuckRight.png' },
                { name: 'leftEnemyWalk1', src: 'leftenemy1.png' }, { name: 'leftEnemyWalk2', src: 'leftenemy2.png' },
                { name: 'leftEnemyExplosion', src: 'leftenemy3.png' }, { name: 'rightEnemyWalk1', src: 'rightenemy1.png' },
                { name: 'rightEnemyWalk2', src: 'rightenemy2.png' }, { name: 'rightEnemyExplosion', src: 'rightenemy3.png' },
                { name: 'Robo1', src: 'Robo1.png' }, { name: 'Robo2', src: 'Robo2.png' },
                { name: 'Robo3', src: 'Robo3.png' }, { name: 'Robo4', src: 'Robo4.png' },
                { name: 'Robo1 copy', src: 'Robo1 copy.png' }, { name: 'Robo2 copy', src: 'Robo2 copy.png' },
                { name: 'Robo3 copy', src: 'Robo3 copy.png' }, { name: 'Robo4 copy', src: 'Robo4 copy.png' },
                { name: 'RoboPOP', src: 'RoboPOP.png' },
                { name: 'background', src: 'SettingSun.png' }, { name: 'foliage1', src: 'foliage1.png' },
                { name: 'foliage2', src: 'foliage2.png' }, { name: 'getReady', src: 'GETREADY.png' },
                { name: 'go', src: 'GO.png' }, { name: 'gameOverTitle', src: 'GAMEOVER.png' },
                { name: 'playAgainButton', src: 'PLAYAGAIN.png' },
                { name: 'BOSS1R', src: 'BOSS1R.png' }, { name: 'BOSS2R', src: 'BOSS2R.png' },
                { name: 'BOSS3R', src: 'BOSS3R.png' }, { name: 'BOSS4R', src: 'BOSS4R.png' },
                // { name: 'BOSS1', src: 'BOSS1.png' }, { name: 'BOSS2', src: 'BOSS2.png' }, // If not used, remove
                // { name: 'BOSS3', src: 'BOSS3.png' }, { name: 'BOSS4', src: 'BOSS4.png' },
            ],

            init() {
                this._assetsToLoadConfig.forEach(asset => this.loadImage(asset.name, asset.src));
            },
            loadImage(name, src) {
                this.totalAssetsToLoad++;
                const img = new Image();
                const promise = new Promise((resolve, reject) => {
                    img.onload = () => { this.images[name] = img; this.loadedAssets++; resolve(img); };
                    img.onerror = (errEvent) => {
                        console.error(`AssetManager ERROR loading image ${name} from ${src}`, errEvent);
                        this.loadedAssets++; reject(new Error(`Failed to load image: ${name}`));
                    };
                });
                img.src = src; this._promises.push(promise); return promise;
            },
            async loadAll() {
                const loadingMessageEl = document.getElementById('loadingMessage');
                if (!loadingMessageEl) console.error("AssetManager: Missing #loadingMessage element!");
                if (this.totalAssetsToLoad === 0) { if (loadingMessageEl) loadingMessageEl.style.display = 'none'; return Promise.resolve(); }
                if (loadingMessageEl) loadingMessageEl.textContent = `LOADING... (0/${this.totalAssetsToLoad})`;
                const progressInterval = setInterval(() => { if (loadingMessageEl) loadingMessageEl.textContent = `LOADING... (${this.loadedAssets}/${this.totalAssetsToLoad})`; }, 100);
                return Promise.all(this._promises.map(p => p.catch(e => e)))
                    .then(results => {
                        const successfulLoads = results.filter(r => !(r instanceof Error));
                        console.log(`AssetManager: Assets loaded successfully: ${successfulLoads.length}/${this.totalAssetsToLoad}`);
                        if (results.some(r => r instanceof Error)) console.warn("AssetManager: Some assets failed to load:", results.filter(r => r instanceof Error));
                    })
                    .catch(error => { console.error("AssetManager: CRITICAL error during loadAll:", error); if (loadingMessageEl) loadingMessageEl.textContent = 'Critical error loading assets!'; })
                    .finally(() => { clearInterval(progressInterval); if (loadingMessageEl) loadingMessageEl.style.display = 'none'; this._promises = []; });
            },
            getImage(name) {
                const img = this.images[name];
                if (img && img.complete && img.naturalHeight === 0) console.warn(`AssetManager: Image "${name}" appears broken: ${img.src}`);
                return img;
            }
        };

        // --- Input Handler ---
        class InputHandler {
            constructor() {
                this.keys = new Set();
                const relevantKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' '];
                window.addEventListener('keydown', e => { if (relevantKeys.includes(e.key)) { e.preventDefault(); this.keys.add(e.key === ' ' ? 'Space' : e.key); }});
                window.addEventListener('keyup', e => { if (relevantKeys.includes(e.key)) { e.preventDefault(); this.keys.delete(e.key === ' ' ? 'Space' : e.key); }});
            }
            isKeyPressed(key) { return this.keys.has(key); }
            consumeShoot() { return this.keys.has('Space'); }
        }

        // --- Projectile Class ---
        class Projectile {
            constructor(x, y, direction, gameWidth, config) { // Pass specific projectile config
                this.x = x; this.y = y; this.direction = direction; this.gameWidth = gameWidth;
                this.width = config.WIDTH; this.height = config.HEIGHT;
                this.speed = config.SPEED; this.color = config.COLOR;
                this.active = true;
            }
            update(deltaTime) {
                const normalizedSpeed = this.speed * (deltaTime / (1000/60)); // Assuming 60 FPS base for speed values
                this.x += (this.direction === 'right' ? normalizedSpeed : -normalizedSpeed);
                if (this.x < -this.width || this.x > this.gameWidth) this.active = false;
            }
            draw(ctx) { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); }
            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
        }


        // --- Enemy Class (Ground Enemy) ---
        class Enemy {
             constructor(x, y, gameWidth) {
                this.gameWidth = gameWidth;
                this.width = ENEMY_CONSTANTS.GROUND.WIDTH; this.height = ENEMY_CONSTANTS.GROUND.HEIGHT;
                this.x = x; this.y = y;
                this.fallbackColor = '#F44336'; // Could be in constants
                this.speed = (Math.random() * (ENEMY_CONSTANTS.GROUND.MAX_SPEED - ENEMY_CONSTANTS.GROUND.MIN_SPEED) + ENEMY_CONSTANTS.GROUND.MIN_SPEED);
                this.active = true;
                this.direction = (x < gameWidth / 2) ? 1 : -1; // 1 for right, -1 for left

                this.walkFrames = []; this.explosionSprite = null;
                if (this.direction === 1) { // Moving Right
                    this.walkFrames = [assetManager.getImage('leftEnemyWalk1'), assetManager.getImage('leftEnemyWalk2')];
                    this.explosionSprite = assetManager.getImage('leftEnemyExplosion');
                } else { // Moving Left
                    this.walkFrames = [assetManager.getImage('rightEnemyWalk1'), assetManager.getImage('rightEnemyWalk2')];
                    this.explosionSprite = assetManager.getImage('rightEnemyExplosion');
                }
                this.currentWalkFrameIndex = 0;
                this.animationTimer = 0; // Switched to time-based animation
                this.animationDelay = ENEMY_CONSTANTS.GROUND.ANIM_DELAY;

                this.isExploding = false;
                this.explosionDuration = ENEMY_CONSTANTS.EXPLOSION_DURATION;
                this.explosionTimer = 0;
                this._spriteMissingLogged = { walk: false, explosion: false };
            }
            update(deltaTime) {
                if (this.isExploding) {
                    this.explosionTimer -= deltaTime;
                    if (this.explosionTimer <= 0) this.active = false;
                    return;
                }
                if (!this.active) return;

                const normalizedSpeed = this.speed * (deltaTime / (1000/60));
                this.x += normalizedSpeed * this.direction;

                this.animationTimer += deltaTime;
                if (this.animationTimer >= this.animationDelay) {
                    this.currentWalkFrameIndex = (this.currentWalkFrameIndex + 1) % (this.walkFrames.length || 1);
                    this.animationTimer = 0;
                }

                if ((this.direction === -1 && this.x < 0 - this.width) || (this.direction === 1 && this.x > this.gameWidth + this.width)) {
                    this.active = false;
                }
            }
            draw(ctx) {
                if (!this.active && !this.isExploding) return;
                let currentSpriteToDraw = null; let spriteType = '';

                if (this.isExploding) { currentSpriteToDraw = this.explosionSprite; spriteType = 'explosion';}
                else if (this.active && this.walkFrames.length > 0 && this.walkFrames[this.currentWalkFrameIndex]) {
                    currentSpriteToDraw = this.walkFrames[this.currentWalkFrameIndex]; spriteType = 'walk';
                }

                if (currentSpriteToDraw && currentSpriteToDraw.complete && currentSpriteToDraw.naturalHeight !== 0) {
                    ctx.drawImage(currentSpriteToDraw, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = this.isExploding ? 'orange' : this.fallbackColor;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    if (spriteType && !this._spriteMissingLogged[spriteType]) {
                        console.warn(`Enemy:draw - Fallback for ${spriteType} sprite. Details:`, currentSpriteToDraw);
                        this._spriteMissingLogged[spriteType] = true;
                    }
                }
            }
            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
            takeDamage() {
                if (this.isExploding || !this.active) return;
                this.isExploding = true;
                this.explosionTimer = this.explosionDuration;
            }
        }

        // --- FlyingEnemy Class ---
        class FlyingEnemy {
            constructor(x, y, gameWidth) {
                this.gameWidth = gameWidth;
                // ** ROBOPOP SCALING APPLIED HERE **
                this.width = ENEMY_CONSTANTS.FLYING.BASE_WIDTH * ENEMY_CONSTANTS.FLYING.SCALE_FACTOR;
                this.height = ENEMY_CONSTANTS.FLYING.BASE_HEIGHT * ENEMY_CONSTANTS.FLYING.SCALE_FACTOR;
                this.x = x; this.y = y;
                this.baseY = y;
                this.fallbackColor = '#ADD8E6';
                this.speed = (Math.random() * (ENEMY_CONSTANTS.FLYING.MAX_SPEED - ENEMY_CONSTANTS.FLYING.MIN_SPEED) + ENEMY_CONSTANTS.FLYING.MIN_SPEED);
                this.active = true;
                this.direction = (x < gameWidth / 2) ? 1 : -1;

                this.waveAmplitude = 25 + (Math.random() * 20); // Keep as is or move to constants if desired
                this.waveFrequency = 0.025 + (Math.random() * 0.015);

                this.animationFrames = []; this.currentFrameIndex = 0;
                this.frameTimer = 0; this.frameDelay = ENEMY_CONSTANTS.FLYING.ANIM_DELAY;

                if (this.direction === 1) { // Moving Right
                    this.animationFrames = [assetManager.getImage('Robo1'), assetManager.getImage('Robo2'), assetManager.getImage('Robo3'), assetManager.getImage('Robo4')];
                } else { // Moving Left
                    this.animationFrames = [assetManager.getImage('Robo1 copy'), assetManager.getImage('Robo2 copy'), assetManager.getImage('Robo3 copy'), assetManager.getImage('Robo4 copy')];
                }
                this.explosionSprite = assetManager.getImage('RoboPOP'); // This will also be drawn scaled due to this.width/height
                this.isExploding = false;
                this.explosionDuration = ENEMY_CONSTANTS.EXPLOSION_DURATION;
                this.explosionTimer = 0;
                this.health = 1;
                this._spriteMissingLogged = { fly: false, explosion: false };
            }
            update(deltaTime) {
                if (this.isExploding) {
                    this.explosionTimer -= deltaTime;
                    if (this.explosionTimer <= 0) this.active = false;
                    return;
                }
                if (!this.active) return;

                const normalizedSpeed = this.speed * (deltaTime / (1000/60));
                this.x += normalizedSpeed * this.direction;
                this.y = this.baseY + Math.sin(this.x * this.waveFrequency) * this.waveAmplitude;

                this.frameTimer += deltaTime;
                if (this.frameTimer >= this.frameDelay) {
                    this.currentFrameIndex = (this.currentFrameIndex + 1) % (this.animationFrames.length || 1);
                    this.frameTimer = 0;
                }
                if ((this.direction === -1 && this.x < 0 - this.width) || (this.direction === 1 && this.x > this.gameWidth + this.width)) {
                    this.active = false;
                }
            }
            draw(ctx) {
                if (!this.active && !this.isExploding) return;
                let currentSpriteToDraw = null; let spriteType = '';

                if (this.isExploding) { currentSpriteToDraw = this.explosionSprite; spriteType = 'explosion'; }
                else if (this.active && this.animationFrames.length > 0 && this.animationFrames[this.currentFrameIndex]) {
                    currentSpriteToDraw = this.animationFrames[this.currentFrameIndex]; spriteType = 'fly';
                }

                if (currentSpriteToDraw && currentSpriteToDraw.complete && currentSpriteToDraw.naturalHeight !== 0) {
                    ctx.drawImage(currentSpriteToDraw, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = this.isExploding ? 'orange' : this.fallbackColor;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    if (spriteType && !this._spriteMissingLogged[spriteType]) {
                        console.warn(`FlyingEnemy:draw - Fallback for ${spriteType} sprite. Details:`, currentSpriteToDraw);
                        this._spriteMissingLogged[spriteType] = true;
                    }
                }
            }
            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
            takeDamage() {
                if (!this.active || this.isExploding) return;
                this.health--;
                if (this.health <= 0) {
                    this.isExploding = true;
                    this.explosionTimer = this.explosionDuration;
                }
            }
        }

        // +++ BOSS Class +++
        class Boss {
            constructor(gameWidth, gameHeight, player) {
                this.gameWidth = gameWidth; this.gameHeight = gameHeight; this.player = player;
                this.width = BOSS_CONSTANTS.WIDTH; this.height = BOSS_CONSTANTS.HEIGHT;
                this.x = gameWidth; this.y = gameHeight - GROUND_Y_OFFSET - this.height;
                this.speed = BOSS_CONSTANTS.SPEED;
                this.health = BOSS_CONSTANTS.HEALTH; this.maxHealth = BOSS_CONSTANTS.HEALTH;
                this.active = true; this.isEntering = true; this.isDestroyed = false;
                this.isFiring = false; this.fallbackColor = '#800080';
                this.stateTimer = 0;
                this.idleDuration = BOSS_CONSTANTS.IDLE_DURATION;
                this.firingDuration = BOSS_CONSTANTS.FIRING_DURATION;
                this.fireCooldown = BOSS_CONSTANTS.FIRE_COOLDOWN;
                this.lastShotTime = 0;
                this.projectiles = [];
                this.sprites = {
                    idle: assetManager.getImage('BOSS1R'), active: assetManager.getImage('BOSS2R'),
                    firing: assetManager.getImage('BOSS3R'), destroyed: assetManager.getImage('BOSS4R'),
                };
                this.currentSprite = this.sprites.idle; this.currentState = 'idle';
                this._spriteMissingLogged = {};
                this.explosionTimer = 0; this.explosionDuration = BOSS_CONSTANTS.EXPLOSION_DURATION;
            }
            update(deltaTime) {
                if (!this.active) return;
                const normalizedSpeed = this.speed * (deltaTime / (1000/60));

                if (this.isDestroyed) {
                    this.explosionTimer -= deltaTime;
                    if (this.explosionTimer <= 0) this.active = false;
                    this.projectiles.forEach(p => p.update(deltaTime));
                    this.projectiles = this.projectiles.filter(p => p.active);
                    return;
                }
                if (this.isEntering) {
                    this.x -= normalizedSpeed * 0.8; // Slower entry
                    this.y = this.gameHeight - GROUND_Y_OFFSET - this.height;
                    if (this.x <= this.gameWidth - this.width - 50) {
                        this.isEntering = false; this.x = this.gameWidth - this.width - 50;
                        this.stateTimer = this.idleDuration; this.currentState = 'idle';
                        this.currentSprite = this.sprites.idle;
                    }
                    return;
                }
                this.y = this.gameHeight - GROUND_Y_OFFSET - this.height; // Keep Y position
                this.stateTimer -= deltaTime;
                if (this.currentState === 'idle') {
                    this.currentSprite = this.sprites.idle;
                    if (this.stateTimer <= 0) {
                        this.currentState = 'firing'; this.isFiring = true;
                        this.stateTimer = this.firingDuration; this.lastShotTime = 0;
                    }
                } else if (this.currentState === 'firing') {
                    this.currentSprite = this.sprites.firing;
                    this.lastShotTime -= deltaTime;
                    if (this.lastShotTime <= 0) { this.shoot(); this.lastShotTime = this.fireCooldown; }
                    if (this.stateTimer <= 0) {
                        this.currentState = 'idle'; this.isFiring = false;
                        this.stateTimer = this.idleDuration; this.currentSprite = this.sprites.idle;
                    }
                }
                this.projectiles.forEach(p => p.update(deltaTime));
                this.projectiles = this.projectiles.filter(p => p.active);
            }
            shoot() {
                const projX = this.x + 30; // Offset from boss's left
                const projY = this.y + this.height * 0.6;
                this.projectiles.push(new Projectile(projX, projY, 'left', this.gameWidth, PROJECTILE_CONSTANTS.BOSS));
            }
            draw(ctx) {
                if (!this.active) return;
                if (this.currentSprite && this.currentSprite.complete && this.currentSprite.naturalHeight !== 0) {
                    ctx.drawImage(this.currentSprite, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = this.fallbackColor; ctx.fillRect(this.x, this.y, this.width, this.height);
                    if (this.currentSprite && !this._spriteMissingLogged[this.currentState]) {
                        console.warn(`Boss:draw - Fallback for ${this.currentState} sprite.`, this.currentSprite);
                        this._spriteMissingLogged[this.currentState] = true;
                    }
                }
                if (!this.isDestroyed && !this.isEntering) { // Health Bar
                    const healthBarWidth = this.width * 0.8; const healthBarHeight = 10;
                    const healthBarX = this.x + (this.width - healthBarWidth) / 2;
                    const healthBarY = this.y - healthBarHeight - 8;
                    ctx.fillStyle = '#555'; ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                    const currentHealthWidth = Math.max(0, healthBarWidth * (this.health / this.maxHealth));
                    ctx.fillStyle = '#FF0000'; ctx.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);
                    ctx.strokeStyle = '#333'; ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                }
                this.projectiles.forEach(p => p.draw(ctx));
            }
            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
            takeDamage() {
                if (this.isDestroyed || this.isEntering) return false;
                this.health--;
                console.log("Boss health:", this.health);
                if (this.health <= 0) {
                    this.health = 0; this.isDestroyed = true;
                    this.currentState = 'destroyed'; this.currentSprite = this.sprites.destroyed;
                    this.explosionTimer = this.explosionDuration; this.projectiles = [];
                    return true; // Was destroyed
                }
                return false; // Damaged but not destroyed
            }
        }

        // --- Player Class ---
        class Player {
            constructor(gameWidth, gameHeight) {
                this.gameWidth = gameWidth; this.gameHeight = gameHeight;
                this.width = PLAYER_CONSTANTS.WIDTH; this.height = PLAYER_CONSTANTS.HEIGHT;
                this.x = 50; this.y = gameHeight - this.height - GROUND_Y_OFFSET;
                this.playerMovedX = 0; // For parallax
                this.fallbackColor = '#4CAF50';
                this.speed = PLAYER_CONSTANTS.SPEED;
                this.projectiles = [];
                this.velocityY = 0; this.gravity = PLAYER_CONSTANTS.GRAVITY;
                this.jumpStrength = PLAYER_CONSTANTS.JUMP_STRENGTH;
                this.onGround = true; this.facingDirection = 'right';
                this.isDucking = false; this.isMovingHorizontally = false;
                this.currentWalkFrame = 0; // 0 or 1
                this.walkAnimationTimer = 0; this.walkAnimationDelay = PLAYER_CONSTANTS.WALK_ANIMATION_DELAY;
                this.shootCooldown = 0; this.shootCooldownTime = PLAYER_CONSTANTS.SHOOT_COOLDOWN_TIME;
                this.health = PLAYER_CONSTANTS.HEALTH; this.isInvincible = false;
                this.invincibilityDuration = PLAYER_CONSTANTS.INVINCIBILITY_DURATION;
                this.invincibilityTimer = 0;
                this._spriteMissingLogged = {};
                // Sprite references (cached after asset loading)
                this.sprites = {
                    idleRight: assetManager.getImage('MGSpriteright'), idleLeft: assetManager.getImage('MGSpriteleft'),
                    walkRight2: assetManager.getImage('MGSpriteright2'), walkLeft2: assetManager.getImage('MGSpriteleft2'),
                    jumpRight: assetManager.getImage('JumpRight'), jumpLeft: assetManager.getImage('JumpLeft'),
                    duckRight: assetManager.getImage('DuckRight'), duckLeft: assetManager.getImage('DuckLeft')
                };
            }

            update(input, deltaTime) {
                const oldPlayerX = this.x;
                const normalizedSpeed = this.speed * (deltaTime / (1000/60)); // Normalize speed
                const normalizedGravity = this.gravity * (deltaTime / (1000/60)); // Normalize gravity if jumpStrength is impulse
                const normalizedJumpStrength = this.jumpStrength; // if jumpStrength is initial velocity, it's fine

                this.isMovingHorizontally = false;
                this.isDucking = input.isKeyPressed('ArrowDown') && this.onGround;

                if (!this.isDucking) {
                    if (input.isKeyPressed('ArrowLeft')) { this.x -= normalizedSpeed; this.facingDirection = 'left'; this.isMovingHorizontally = true; }
                    if (input.isKeyPressed('ArrowRight')) { this.x += normalizedSpeed; this.facingDirection = 'right'; this.isMovingHorizontally = true; }
                    if (input.isKeyPressed('ArrowUp') && this.onGround) { this.velocityY = normalizedJumpStrength; this.onGround = false; }
                }
                this.playerMovedX = this.x - oldPlayerX;

                if (this.isMovingHorizontally && this.onGround && !this.isDucking) {
                    this.walkAnimationTimer += deltaTime;
                    if (this.walkAnimationTimer >= this.walkAnimationDelay) { this.currentWalkFrame = 1 - this.currentWalkFrame; this.walkAnimationTimer = 0; }
                } else { this.currentWalkFrame = 0; this.walkAnimationTimer = 0; } // Reset if not walking

                this.y += this.velocityY * (deltaTime / (1000/60)); // Apply normalization to velocity change too
                this.velocityY += normalizedGravity;
                const groundLevel = this.gameHeight - this.height - GROUND_Y_OFFSET;
                if (this.y >= groundLevel) { this.y = groundLevel; this.velocityY = 0; this.onGround = true; }

                if (this.x < 0) this.x = 0;
                if (this.x + this.width > this.gameWidth) this.x = this.gameWidth - this.width;

                if (this.shootCooldown > 0) this.shootCooldown -= deltaTime;
                if (input.consumeShoot() && this.shootCooldown <= 0) {
                    this.shoot(); this.shootCooldown = this.shootCooldownTime;
                }
                this.projectiles.forEach(p => p.update(deltaTime));
                this.projectiles = this.projectiles.filter(p => p.active);

                if (this.isInvincible) { this.invincibilityTimer -= deltaTime; if (this.invincibilityTimer <= 0) this.isInvincible = false; }
            }

            updateVisualsOnly(deltaTime) { /* For PRE_GAME states - only update things like invincibility blink */
                this.currentWalkFrame = 0; this.walkAnimationTimer = 0;
                 if (this.isInvincible) { this.invincibilityTimer -= deltaTime; if (this.invincibilityTimer <= 0) this.isInvincible = false; }
            }

            shoot() {
                const projX = this.facingDirection === 'right' ? this.x + this.width : this.x - PROJECTILE_CONSTANTS.PLAYER.WIDTH; // Adjust for bullet width
                // ** CROUCH BULLET HEIGHT CHANGE APPLIED HERE **
                // Bullet originates from the same vertical position regardless of ducking.
                const projY = this.y + (this.height / PLAYER_CONSTANTS.BULLET_Y_OFFSET_DIVISOR) - (PROJECTILE_CONSTANTS.PLAYER.HEIGHT / 2);

                this.projectiles.push(new Projectile(projX, projY, this.facingDirection, this.gameWidth, PROJECTILE_CONSTANTS.PLAYER));
            }
            draw(ctx) {
                let currentSprite = null; let spriteKey = '';
                if (this.isDucking) {
                    spriteKey = this.facingDirection === 'right' ? 'DuckRight' : 'DuckLeft';
                    currentSprite = this.facingDirection === 'right' ? this.sprites.duckRight : this.sprites.duckLeft;
                } else if (!this.onGround) {
                    spriteKey = this.facingDirection === 'right' ? 'JumpRight' : 'JumpLeft';
                    currentSprite = this.facingDirection === 'right' ? this.sprites.jumpRight : this.sprites.jumpLeft;
                } else {
                    if (this.isMovingHorizontally) {
                        if (this.facingDirection === 'right') {
                            spriteKey = this.currentWalkFrame === 0 ? 'MGSpriteright' : 'MGSpriteright2';
                            currentSprite = this.currentWalkFrame === 0 ? this.sprites.idleRight : this.sprites.walkRight2;
                        } else {
                            spriteKey = this.currentWalkFrame === 0 ? 'MGSpriteleft' : 'MGSpriteleft2';
                            currentSprite = this.currentWalkFrame === 0 ? this.sprites.idleLeft : this.sprites.walkLeft2;
                        }
                    } else { // Idle
                        spriteKey = this.facingDirection === 'right' ? 'MGSpriteright' : 'MGSpriteleft';
                        currentSprite = this.facingDirection === 'right' ? this.sprites.idleRight : this.sprites.idleLeft;
                    }
                }

                if (this.isInvincible) ctx.globalAlpha = (Math.floor(Date.now() / 100) % 2 === 0) ? 0.6 : 1.0;

                let drewSprite = false;
                if (currentSprite && currentSprite.complete && currentSprite.naturalHeight !== 0) {
                    try { ctx.drawImage(currentSprite, this.x, this.y, this.width, this.height); drewSprite = true; }
                    catch (e) { console.error("Player:draw Error:", e, currentSprite); }
                }
                if (!drewSprite) {
                    ctx.fillStyle = this.fallbackColor; ctx.fillRect(this.x, this.y, this.width, this.height);
                    if (spriteKey && !this._spriteMissingLogged[spriteKey]) {
                        console.warn(`Player:draw Fallback key "${spriteKey}"`, currentSprite);
                        this._spriteMissingLogged[spriteKey] = true;
                    }
                }
                ctx.globalAlpha = 1.0;
                this.projectiles.forEach(p => p.draw(ctx));
            }
            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
            takeDamage() {
                if (this.isInvincible) return false; // No damage
                this.health--;
                if (this.health > 0) { this.isInvincible = true; this.invincibilityTimer = this.invincibilityDuration; }
                return true; // Damage taken
            }
        }

        // --- Game Class ---
        class Game {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                if (!this.canvas || !this.ctx) { alert("Error: Canvas not supported or found."); throw new Error("Canvas initialization failed"); }

                this.canvas.width = CANVAS_WIDTH; this.canvas.height = CANVAS_HEIGHT;
                this.inputHandler = new InputHandler();
                this.player = null; this.enemies = []; this.score = 0; this.lastTime = 0;
                this.animationFrameId = null;
                this.enemySpawnTimer = 0; this.enemySpawnInterval = 2500; //ms
                this.gameLoop = this.gameLoop.bind(this);
                this.backgroundSprite = null; this.foliageSprite1 = null; this.foliageSprite2 = null;
                this.foliageX = 0; this.foliageScrollSpeedFactor = 0.3;
                this.gameState = 'LOADING'; // LOADING, PRE_GAME_GET_READY, PRE_GAME_GO, RUNNING, GAME_OVER
                this.getReadySprite = null; this.goSprite = null;
                this.gameOverSprite = null; this.playAgainButtonSprite = null;
                this.preGameMessageTimer = 0; this.getReadyDuration = 2000; this.goDuration = 1000;
                this.playAgainButtonRect = null;
                this.canvas.addEventListener('click', this.handleCanvasClick.bind(this));

                this.boss = null;
                this.bossSpawnScoreInterval = 1000;
                this.nextBossSpawnScore = 500;
            }

            handleCanvasClick(event) {
                if (this.gameState !== 'GAME_OVER' || !this.playAgainButtonRect) return;
                const rect = this.canvas.getBoundingClientRect();
                const clickX = event.clientX - rect.left; const clickY = event.clientY - rect.top;
                if (AABBCollision({x: clickX, y: clickY, width:1, height:1}, this.playAgainButtonRect)) {
                    this.resetGame();
                }
            }
            resetGame() {
                this.gameState = 'PRE_GAME_GET_READY'; this.preGameMessageTimer = this.getReadyDuration;
                this.score = 0; this.enemies = []; this.enemySpawnTimer = 0; this.enemySpawnInterval = 2500;
                this.playAgainButtonRect = null; this.canvas.classList.remove('clickable');
                if (this.player) {
                    this.player.x = 50; this.player.y = this.canvas.height - this.player.height - GROUND_Y_OFFSET;
                    this.player.velocityY = 0; this.player.onGround = true; this.player.facingDirection = 'right';
                    this.player.health = PLAYER_CONSTANTS.HEALTH; this.player.projectiles = []; this.player.isInvincible = false;
                    this.player.invincibilityTimer = 0; this.player.isMovingHorizontally = false; this.player.currentWalkFrame = 0;
                }
                this.boss = null;
                this.nextBossSpawnScore = 500;
                console.log("Game: Game reset, boss state cleared. Next boss at score:", this.nextBossSpawnScore);
            }

            spawnEnemy() {
                let newEnemy = null; const spawnFlyingChance = 0.35;
                const enemyYGround = this.canvas.height - GROUND_Y_OFFSET - ENEMY_CONSTANTS.GROUND.HEIGHT;
                const flyingEnemyY = this.canvas.height * 0.3 + Math.random() * (this.canvas.height * 0.33);
                let spawnX = (Math.random() < 0.5) ? (0 - (Math.random() * 50 + 50)) : (this.canvas.width + Math.random() * 50);

                if (Math.random() < spawnFlyingChance) {
                    newEnemy = new FlyingEnemy(spawnX, flyingEnemyY, this.canvas.width);
                } else {
                    newEnemy = new Enemy(spawnX, enemyYGround, this.canvas.width);
                }
                if (newEnemy) this.enemies.push(newEnemy);
            }
            spawnBoss() {
                if (!this.boss && this.player) {
                    console.log(`Game: Spawning Boss! Current score: ${this.score}, Next boss score: ${this.nextBossSpawnScore}`);
                    this.boss = new Boss(this.canvas.width, this.canvas.height, this.player);
                    this.enemies = []; // Clear regular enemies when boss appears
                }
            }

            update(deltaTime) {
                if (!this.player && this.gameState !== 'LOADING' && this.gameState !== 'GAME_OVER') { console.warn("Game: Player not initialized during an active game state:", this.gameState); return; }
                this.canvas.classList.toggle('clickable', this.gameState === 'GAME_OVER' && !!this.playAgainButtonRect);

                switch (this.gameState) {
                    case 'LOADING': return; // No updates while loading
                    case 'PRE_GAME_GET_READY':
                        this.preGameMessageTimer -= deltaTime;
                        if (this.preGameMessageTimer <= 0) { this.gameState = 'PRE_GAME_GO'; this.preGameMessageTimer = this.goDuration; }
                        if (this.player) this.player.updateVisualsOnly(deltaTime); // For invincibility flash etc.
                        return;
                    case 'PRE_GAME_GO':
                        this.preGameMessageTimer -= deltaTime;
                        if (this.preGameMessageTimer <= 0) { this.gameState = 'RUNNING'; }
                        if (this.player) this.player.updateVisualsOnly(deltaTime);
                        return;
                    case 'GAME_OVER': return; // No game logic updates once over
                    case 'RUNNING': break; // Continue to RUNNING state logic
                    default: console.warn("Game: Unknown game state:", this.gameState); return;
                }

                // --- RUNNING STATE LOGIC ---
                if (this.score >= this.nextBossSpawnScore && !this.boss) this.spawnBoss();

                this.player.update(this.inputHandler, deltaTime);
                let bossDefeatedThisFrame = false;

                if (this.boss && this.boss.active) {
                    this.boss.update(deltaTime);
                    // Player Projectiles vs Boss
                    this.player.projectiles.forEach(proj => {
                        if (proj.active && AABBCollision(proj.getRect(), this.boss.getRect()) && !this.boss.isDestroyed && !this.boss.isEntering) {
                            proj.active = false;
                            this.score += BOSS_CONSTANTS.SCORE_HIT;
                            if (this.boss.takeDamage()) { // takeDamage returns true if boss was destroyed
                                this.score += (BOSS_CONSTANTS.SCORE_DEFEAT - BOSS_CONSTANTS.SCORE_HIT); // Add remaining bonus
                                bossDefeatedThisFrame = true;
                            }
                        }
                    });
                    // Boss Projectiles vs Player
                    if (!this.player.isInvincible) { this.boss.projectiles.forEach(bossProj => { if (bossProj.active && AABBCollision(bossProj.getRect(), this.player.getRect())) { bossProj.active = false; if (this.player.takeDamage() && this.player.health <= 0) { this.gameOver(); } } }); }
                    // Player vs Boss Body
                    if (!this.player.isInvincible && AABBCollision(this.player.getRect(), this.boss.getRect()) && !this.boss.isDestroyed && !this.boss.isEntering) { if (this.player.takeDamage() && this.player.health <= 0) { this.gameOver(); } }

                    if (bossDefeatedThisFrame) {
                        this.nextBossSpawnScore = this.score + this.bossSpawnScoreInterval;
                        console.log("Boss defeated! Next boss will spawn at score:", this.nextBossSpawnScore);
                        // Note: Boss instance remains until its 'active' flag is false (after explosion)
                    }
                } else { // No active boss, so update regular enemies
                    this.enemies.forEach(enemy => enemy.update(deltaTime));
                    this.player.projectiles.forEach(proj => { this.enemies.forEach(enemy => { if (proj.active && enemy.active && !enemy.isExploding && AABBCollision(proj.getRect(), enemy.getRect())) { proj.active = false; enemy.takeDamage(); this.score += (enemy instanceof FlyingEnemy ? ENEMY_CONSTANTS.FLYING.SCORE : ENEMY_CONSTANTS.GROUND.SCORE); } }); });
                    this.enemies.forEach(enemy => { if (enemy.active && !enemy.isExploding && AABBCollision(this.player.getRect(), enemy.getRect())) { if (this.player.takeDamage() && this.player.health <= 0) { this.gameOver(); } } });

                    if (!this.boss) { // Only spawn regular enemies if no boss is present or trying to spawn
                        this.enemySpawnTimer += deltaTime;
                        if (this.enemySpawnTimer >= this.enemySpawnInterval) {
                            if (this.enemies.length < 8) this.spawnEnemy();
                            this.enemySpawnTimer = 0;
                            if (this.enemySpawnInterval > 800) this.enemySpawnInterval -= 20;
                        }
                    }
                }

                this.player.projectiles = this.player.projectiles.filter(p => p.active);
                if (this.boss) this.boss.projectiles = this.boss.projectiles.filter(p => p.active);
                this.enemies = this.enemies.filter(e => e.active || e.isExploding); // Keep exploding ones for their animation

                if (this.boss && !this.boss.active && !this.boss.isEntering) { // If boss was defeated and its animation finished
                    this.boss = null;
                }

                // Parallax scrolling
                if (this.player.playerMovedX !== 0 && this.foliageSprite1 && this.foliageSprite2) {
                    this.foliageX -= this.player.playerMovedX * this.foliageScrollSpeedFactor;
                    const combinedFoliageWidth = (this.foliageSprite1.width || 0) + (this.foliageSprite2.width || 0);
                    if (combinedFoliageWidth > 0) { this.foliageX %= combinedFoliageWidth; }
                }
                this.player.playerMovedX = 0;
            }

            drawPlayerHealth() { if (!this.player) return; this.ctx.fillStyle = 'white'; this.ctx.font = '18px "Press Start 2P"'; this.ctx.textAlign = 'right'; this.ctx.fillText(`Health: ${"❤️".repeat(Math.max(0, this.player.health))}`, this.canvas.width - 20, 30); }
            draw() {
                // Background
                if (this.backgroundSprite && this.backgroundSprite.complete && this.backgroundSprite.naturalHeight !== 0) { this.ctx.drawImage(this.backgroundSprite, 0, 0, this.canvas.width, this.canvas.height); }
                else { this.ctx.fillStyle = '#2c3e50'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); } // Fallback

                // Foliage
                if (this.foliageSprite1 && this.foliageSprite1.complete && this.foliageSprite1.naturalHeight !==0 &&
                    this.foliageSprite2 && this.foliageSprite2.complete && this.foliageSprite2.naturalHeight !== 0) {
                    const f1W = this.foliageSprite1.width; const f2W = this.foliageSprite2.width; const cW = f1W + f2W;
                    if (cW > 0) { // Ensure sprites are loaded
                        let sX = this.foliageX % cW; if(sX > 0) sX -= cW; // Ensure start is 0 or negative
                        for(let cX = sX; cX < this.canvas.width; cX += cW){
                            this.ctx.drawImage(this.foliageSprite1, cX, 0, f1W, this.canvas.height);
                            this.ctx.drawImage(this.foliageSprite2, cX + f1W, 0, f2W, this.canvas.height);
                        }
                    }
                }
                // Ground
                this.ctx.fillStyle = '#7f8c8d'; this.ctx.fillRect(0, this.canvas.height - GROUND_Y_OFFSET, this.canvas.width, GROUND_Y_OFFSET);

                if (this.player) { this.player.draw(this.ctx); }
                else if (this.gameState !== 'LOADING' && this.gameState !== 'GAME_OVER') {
                    this.ctx.fillStyle = 'white'; this.ctx.font = '20px "Press Start 2P"';
                    this.ctx.textAlign = 'center'; this.ctx.fillText('Initializing Player...', this.canvas.width / 2, this.canvas.height / 2);
                }

                switch (this.gameState) {
                    case 'PRE_GAME_GET_READY': this._drawPreGameMessage(this.getReadySprite); break;
                    case 'PRE_GAME_GO': this._drawPreGameMessage(this.goSprite); break;
                    case 'RUNNING':
                        this.enemies.forEach(enemy => enemy.draw(this.ctx));
                        if (this.boss && this.boss.active) { this.boss.draw(this.ctx); }
                        this.ctx.fillStyle = 'white'; this.ctx.font = '20px "Press Start 2P"';
                        this.ctx.textAlign = 'left'; this.ctx.fillText(`Score: ${this.score}`, 20, 30);
                        this.drawPlayerHealth();
                        break;
                    case 'GAME_OVER': this.drawGameOverScreen(); break;
                }
            }
            _drawPreGameMessage(sprite) {
                if (sprite && sprite.complete && sprite.naturalHeight !== 0) {
                    const scale = 0.7;
                    const newWidth = sprite.width * scale; const newHeight = sprite.height * scale;
                    const x = (this.canvas.width - newWidth) / 2; const y = (this.canvas.height - newHeight) / 2;
                    this.ctx.drawImage(sprite, x, y, newWidth, newHeight);
                }
            }

            drawGameOverScreen() {
                this.ctx.fillStyle = 'rgba(0,0,0,0.85)'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                const titleScale = 0.25; const scoreFontSize = 18; const buttonScale = 0.15;
                const vertPaddingTitle = 20; const vertPaddingScore = 15;
                let currentY = this.canvas.height * 0.12;

                if (this.gameOverSprite && this.gameOverSprite.complete && this.gameOverSprite.naturalHeight !== 0) {
                    const nW = this.gameOverSprite.width * titleScale; const nH = this.gameOverSprite.height * titleScale;
                    const sX = (this.canvas.width - nW) / 2;
                    this.ctx.drawImage(this.gameOverSprite, sX, currentY, nW, nH);
                    currentY += nH + vertPaddingTitle;
                } else {
                    this.ctx.font = '30px "Press Start 2P"'; this.ctx.fillStyle = '#E74C3C'; this.ctx.textAlign = 'center';
                    const tM = this.ctx.measureText('GAME OVER'); const tH = (tM.actualBoundingBoxAscent + tM.actualBoundingBoxDescent) || 30;
                    this.ctx.fillText('GAME OVER', this.canvas.width / 2, currentY + tH / 2);
                    currentY += tH + vertPaddingTitle;
                }
                this.ctx.font = `${scoreFontSize}px "Press Start 2P"`; this.ctx.fillStyle = 'white'; this.ctx.textAlign = 'center';
                const sT = `Final Score: ${this.score}`; const sTEH = scoreFontSize * 1.2;
                this.ctx.fillText(sT, this.canvas.width / 2, currentY + sTEH / 2);
                currentY += sTEH + vertPaddingScore;

                if (this.playAgainButtonSprite && this.playAgainButtonSprite.complete && this.playAgainButtonSprite.naturalHeight !== 0) {
                    const nBW = this.playAgainButtonSprite.width * buttonScale; const nBH = this.playAgainButtonSprite.height * buttonScale;
                    const bX = (this.canvas.width - nBW) / 2; const bY = currentY;
                    this.ctx.drawImage(this.playAgainButtonSprite, bX, bY, nBW, nBH);
                    this.playAgainButtonRect = { x: bX, y: bY, width: nBW, height: nBH };
                } else {
                    this.ctx.font = '16px "Press Start 2P"';
                    this.ctx.fillText('Refresh to Play Again', this.canvas.width / 2, currentY + (16 * 0.6));
                    this.playAgainButtonRect = null;
                }
            }
            gameOver() { this.gameState = 'GAME_OVER'; console.log("Game: Game Over."); }
            gameLoop(timestamp) {
                const dT = Math.min(100, timestamp - (this.lastTime || timestamp)); // Cap delta time to prevent huge leaps
                this.lastTime = timestamp;
                this.update(dT);
                this.draw();
                this.animationFrameId = requestAnimationFrame(this.gameLoop);
            }

            async initAndStart() {
                console.log("Game: Starting asset loading phase."); this.gameState = 'LOADING';
                assetManager.init(); // Call init to queue up images from its config

                try {
                    await assetManager.loadAll(); console.log("Game: Asset loading complete.");
                    this.backgroundSprite = assetManager.getImage('background');
                    this.foliageSprite1 = assetManager.getImage('foliage1'); this.foliageSprite2 = assetManager.getImage('foliage2');
                    this.getReadySprite = assetManager.getImage('getReady'); this.goSprite = assetManager.getImage('go');
                    this.gameOverSprite = assetManager.getImage('gameOverTitle');
                    this.playAgainButtonSprite = assetManager.getImage('playAgainButton');
                    if (!this.backgroundSprite) console.warn("Game: Background sprite not loaded!");
                } catch (err) { console.error("Game: Critical error loading assets:", err); this.gameState = 'ERROR_LOADING'; return; }

                this.player = new Player(this.canvas.width, this.canvas.height);
                console.log("Game: Player initialized.");
                this.resetGame(); // This sets the state to PRE_GAME_GET_READY
                if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
                this.lastTime = 0; // performance.now();
                console.log("Game: Starting game loop.");
                this.animationFrameId = requestAnimationFrame(this.gameLoop);
            }
        }

        // --- Initialize Game ---
        window.addEventListener('DOMContentLoaded', () => {
            console.log("Script: DOMContentLoaded event fired.");
            try {
                const game = new Game('gameCanvas');
                console.log("Script: Game instance created. Calling initAndStart...");
                game.initAndStart().catch(err => {
                    console.error("Script: FATAL - Failed to initialize and start game (async error):", err);
                    const loadingMessageEl = document.getElementById('loadingMessage');
                    if (loadingMessageEl) loadingMessageEl.textContent = "FATAL ERROR starting game. Check console.";
                    else alert("FATAL ERROR starting game. Check console.");
                });
            } catch (e) {
                console.error("Script: FATAL - Error creating Game instance (sync error):", e);
                const loadingMessageEl = document.getElementById('loadingMessage');
                if (loadingMessageEl) loadingMessageEl.textContent = "Critical error creating game instance. Check console.";
                else alert("Critical error: Game could not be created. Check console.");
            }
         });
        console.log("Script: Initial setup execution finished.");
    </script>
</body>
</html>
