<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metal Lugs</title>
    <style>
        body {
            font-family: 'Press Start 2P', cursive, sans-serif;
            background-color: #1a1a1a;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding-top: 10px;
            height: 100vh;
            overflow: hidden;
        }
        #gameTitleImage {
            display: block;
            margin: 0 auto 10px auto;
            max-width: 90%;
            width: 350px;
            height: auto;
        }
        .game-settings {
            margin-bottom: 10px;
            font-size: 0.8em;
            color: #ccc;
            background-color: rgba(0,0,0,0.5);
            padding: 6px 10px;
            border-radius: 5px;
            text-align: center;
        }
        .game-settings label {
            margin-left: 10px;
            cursor: pointer;
        }
        .game-settings input[type="radio"] {
            vertical-align: middle;
            margin-right: 3px;
        }
        canvas {
            border: 4px solid #fff;
            background-color: #000;
            display: block;
            box-shadow: 0 0 15px #fff;
            cursor: default;
        }
        canvas.clickable {
            cursor: pointer;
        }
        .controls-info {
            margin-top: 10px;
            font-size: 0.8em;
            color: #ccc;
            background-color: rgba(0,0,0,0.5);
            padding: 6px 10px;
            border-radius: 5px;
        }
         #loadingMessage {
            color: yellow;
            font-style: italic;
        }
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    </style>
</head>
<body>
    <img id="gameTitleImage" src="METALLUGS.png" alt="Metal Lugs Title">

    <div class="game-settings">
        <span>Speed:</span>
        <label><input type="radio" name="speedSetting" value="normal" checked> Normal</label>
        <label><input type="radio" name="speedSetting" value="turbo"> Turbo</label>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div class="controls-info">
        <p>Controls: Arrow Keys (Move/Jump/Duck), Spacebar (Shoot)</p>
        <p id="loadingMessage">LOADING ASSETS...</p>
    </div>

    <script>
        console.log("Script execution started.");

        // --- Global Constants & Audio ---
        const NORMAL_FRAME_DURATION_MS = 1000 / 60;
        let audioCtx; // Will be initialized on first sound play or user interaction

        function getAudioContext() {
            if (!audioCtx) {
                try {
                    // Create AudioContext after a user gesture (like a click) for browser compatibility
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error("Web Audio API is not supported in this browser.", e);
                    return null;
                }
            }
            // If context is suspended, resume it (often needed after user gesture)
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume().catch(e => console.error("Error resuming AudioContext:", e));
            }
            return audioCtx;
        }

        function playClickSound() {
            const context = getAudioContext();
            if (!context || context.state !== 'running') { // Check if context is running
                 // console.warn("AudioContext not running, cannot play click sound.");
                return;
            }

            const oscillator = context.createOscillator();
            const gainNode = context.createGain();

            oscillator.type = 'triangle';
            oscillator.frequency.setValueAtTime(1200, context.currentTime);
            gainNode.gain.setValueAtTime(0.2, context.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, context.currentTime + 0.05);

            oscillator.connect(gainNode);
            gainNode.connect(context.destination);

            oscillator.start(context.currentTime);
            oscillator.stop(context.currentTime + 0.05);
        }

        function playLaserSound(volume = 0.15, startFreq = 1000, endFreq = 200, duration = 0.1) {
            const context = getAudioContext();
            if (!context || context.state !== 'running') { // Check if context is running
                // console.warn("AudioContext not running, cannot play laser sound.");
                return;
            }

            const oscillator = context.createOscillator();
            const gainNode = context.createGain();

            oscillator.type = 'sawtooth';
            gainNode.gain.setValueAtTime(volume, context.currentTime);
            oscillator.frequency.setValueAtTime(startFreq, context.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(endFreq, context.currentTime + duration);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, context.currentTime + duration + 0.02);

            oscillator.connect(gainNode);
            gainNode.connect(context.destination);

            oscillator.start(context.currentTime);
            oscillator.stop(context.currentTime + duration + 0.02);
        }


        // --- Utility Functions ---
        function AABBCollision(rect1, rect2) {
            return (
                rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y
            );
        }

        // --- Asset Manager ---
        const assetManager = {
            images: {},
            totalAssetsToLoad: 0,
            loadedAssets: 0,
            _promises: [],
            loadImage(name, src) {
                this.totalAssetsToLoad++;
                const img = new Image();
                const promise = new Promise((resolve, reject) => {
                    img.onload = () => {
                        this.images[name] = img;
                        this.loadedAssets++;
                        resolve(img);
                    };
                    img.onerror = (errEvent) => {
                        console.error(`AssetManager ERROR loading image ${name} from ${src}`, errEvent);
                        this.loadedAssets++;
                        reject(new Error(`Failed to load image: ${name}`));
                    };
                });
                img.src = src;
                this._promises.push(promise);
                return promise;
            },
            async loadAll() {
                const loadingMessageEl = document.getElementById('loadingMessage');
                if (!loadingMessageEl) { console.error("AssetManager: Missing #loadingMessage element!"); }
                if (this.totalAssetsToLoad === 0) {
                    if (loadingMessageEl) loadingMessageEl.style.display = 'none';
                    return Promise.resolve();
                }
                if (loadingMessageEl) loadingMessageEl.textContent = `LOADING... (0/${this.totalAssetsToLoad})`;
                const progressInterval = setInterval(() => {
                    if (loadingMessageEl) loadingMessageEl.textContent = `LOADING... (${this.loadedAssets}/${this.totalAssetsToLoad})`;
                }, 100);
                return Promise.all(this._promises.map(p => p.catch(e => e)))
                    .then((results) => {
                        const successfulLoads = results.filter(r => !(r instanceof Error));
                        console.log(`AssetManager: Assets loaded successfully: ${successfulLoads.length}/${this.totalAssetsToLoad}`);
                        if (results.some(r => r instanceof Error)) {
                            console.warn("AssetManager: Some assets failed to load:", results.filter(r => r instanceof Error));
                        }
                    })
                    .catch((error) => {
                        console.error("AssetManager: CRITICAL error during loadAll:", error);
                        if (loadingMessageEl) loadingMessageEl.textContent = 'Critical error loading assets!';
                    })
                    .finally(() => {
                        clearInterval(progressInterval);
                        if (loadingMessageEl) loadingMessageEl.style.display = 'none';
                        this._promises = [];
                    });
            },
            getImage(name) {
                const img = this.images[name];
                if (img && img.complete && img.naturalHeight === 0) {
                    console.warn(`AssetManager: Image "${name}" appears to be broken or has an invalid path: ${img.src}`);
                }
                return img;
            }
        };

        // --- Input Handler ---
        class InputHandler {
            constructor() {
                this.keys = new Set();
                const relevantKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' '];
                window.addEventListener('keydown', (e) => {
                    if (relevantKeys.includes(e.key)) {
                        e.preventDefault();
                        getAudioContext(); // Attempt to initialize/resume AudioContext on first keydown
                        this.keys.add(e.key === ' ' ? 'Space' : e.key);
                    }
                });
                window.addEventListener('keyup', (e) => {
                    if (relevantKeys.includes(e.key)) {
                        e.preventDefault();
                        this.keys.delete(e.key === ' ' ? 'Space' : e.key);
                    }
                });
            }
            isKeyPressed(key) { return this.keys.has(key); }
            consumeShoot() { return this.keys.has('Space'); }
        }

        // --- Projectile Class ---
        class Projectile {
            constructor(x, y, direction, gameWidth, color = '#FFEB3B', speed = 9, width = 10, height = 5, sprite = null) {
                this.x = x; this.y = y; this.direction = direction; this.gameWidth = gameWidth;
                this.width = width; this.height = height; this.speed = speed;
                this.color = color;
                this.sprite = sprite;
                this.active = true;
            }
            update(effectiveDeltaTime, timeScaleFactor) {
                this.x += (this.direction === 'right' ? this.speed * timeScaleFactor : -this.speed * timeScaleFactor);
                if (this.x < -this.width || this.x > this.gameWidth) {
                    this.active = false;
                }
            }
            draw(ctx) {
                if (this.sprite && this.sprite.complete && this.sprite.naturalHeight !== 0) {
                    ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height);
                } else if (this.color) {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = 'magenta';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }
            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
        }

        // --- Enemy Class ---
        class Enemy {
             constructor(x, y, gameWidth) {
                this.gameWidth = gameWidth; this.width = 50;  this.height = 75;
                this.x = x; this.y = y;
                this.fallbackColor = '#F44336';
                this.speed = (Math.random() * 1.0 + 0.5);
                this.active = true;
                this.direction = (x < gameWidth / 2) ? 1 : -1;
                this.walkFrames = []; this.explosionSprite = null;
                if (this.direction === 1) {
                    this.walkFrames = [assetManager.getImage('leftEnemyWalk1'), assetManager.getImage('leftEnemyWalk2')];
                    this.explosionSprite = assetManager.getImage('leftEnemyExplosion');
                } else {
                    this.walkFrames = [assetManager.getImage('rightEnemyWalk1'), assetManager.getImage('rightEnemyWalk2')];
                    this.explosionSprite = assetManager.getImage('rightEnemyExplosion');
                }
                this.currentWalkFrameIndex = 0;
                this.pixelsMovedSinceFrameChange = 0;
                this.animationPixelThreshold = 20;
                this.isExploding = false; this.explosionDuration = 300; this.explosionTimer = 0;
                this._spriteMissingLogged = { walk: false, explosion: false };
            }
            update(effectiveDeltaTime, timeScaleFactor) {
                if (this.isExploding) {
                    this.explosionTimer -= effectiveDeltaTime;
                    if (this.explosionTimer <= 0) this.active = false;
                    return;
                }
                if (!this.active) return;
                const oldX = this.x;
                this.x += this.speed * this.direction * timeScaleFactor;
                const movedDistance = Math.abs(this.x - oldX);
                this.pixelsMovedSinceFrameChange += movedDistance;
                if (this.pixelsMovedSinceFrameChange >= this.animationPixelThreshold) {
                    this.currentWalkFrameIndex = (this.currentWalkFrameIndex + 1) % (this.walkFrames.length || 1);
                    this.pixelsMovedSinceFrameChange = 0;
                }
                if ((this.direction === -1 && this.x < 0 - this.width) || (this.direction === 1 && this.x > this.gameWidth + this.width)) {
                    this.active = false;
                }
            }
            draw(ctx) {
                if (!this.active && !this.isExploding) return;
                let currentSpriteToDraw = null; let spriteType = '';
                if (this.isExploding) {
                    currentSpriteToDraw = this.explosionSprite; spriteType = 'explosion';
                } else if (this.active && this.walkFrames.length > 0 && this.walkFrames[this.currentWalkFrameIndex]) {
                    currentSpriteToDraw = this.walkFrames[this.currentWalkFrameIndex]; spriteType = 'walk';
                }
                if (currentSpriteToDraw && currentSpriteToDraw.complete && currentSpriteToDraw.naturalHeight !== 0) {
                    ctx.drawImage(currentSpriteToDraw, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = this.isExploding ? 'orange' : this.fallbackColor;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    if (spriteType && !this._spriteMissingLogged[spriteType]) {
                        console.warn(`Enemy:draw - Fallback for ${spriteType} sprite. Details:`, currentSpriteToDraw);
                        this._spriteMissingLogged[spriteType] = true;
                    }
                }
            }
            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
            takeDamage() {
                if (this.isExploding || !this.active) return;
                this.isExploding = true;
                this.explosionTimer = this.explosionDuration;
            }
        }

        // --- FlyingEnemy Class ---
        class FlyingEnemy {
            constructor(x, y, gameWidth) {
                this.gameWidth = gameWidth;
                this.width = 48; this.height = 48; this.x = x; this.y = y;
                this.baseY = y;
                this.fallbackColor = '#ADD8E6';
                this.speed = (Math.random() * 1.5 + 1.0);
                this.active = true;
                this.direction = (x < gameWidth / 2) ? 1 : -1;
                this.waveAmplitude = 25 + (Math.random() * 20);
                this.waveFrequency = 0.025 + (Math.random() * 0.015);
                this.animationFrames = []; this.currentFrameIndex = 0;
                this.frameTimer = 0; this.frameDelay = 120;
                if (this.direction === 1) {
                    this.animationFrames = [assetManager.getImage('Robo1'), assetManager.getImage('Robo2'), assetManager.getImage('Robo3'), assetManager.getImage('Robo4')];
                } else {
                    this.animationFrames = [assetManager.getImage('Robo1 copy'), assetManager.getImage('Robo2 copy'), assetManager.getImage('Robo3 copy'), assetManager.getImage('Robo4 copy')];
                }
                this.explosionSprite = assetManager.getImage('RoboPOP');
                this.isExploding = false; this.explosionDuration = 300; this.explosionTimer = 0;
                this.health = 1;
                this._spriteMissingLogged = { fly: false, explosion: false };
            }
            update(effectiveDeltaTime, timeScaleFactor) {
                if (this.isExploding) {
                    this.explosionTimer -= effectiveDeltaTime;
                    if (this.explosionTimer <= 0) this.active = false;
                    return;
                }
                if (!this.active) return;
                this.x += this.speed * this.direction * timeScaleFactor;
                this.y = this.baseY + Math.sin(this.x * this.waveFrequency) * this.waveAmplitude;
                this.frameTimer += effectiveDeltaTime;
                if (this.frameTimer >= this.frameDelay) {
                    this.currentFrameIndex = (this.currentFrameIndex + 1) % (this.animationFrames.length || 1);
                    this.frameTimer = 0;
                }
                if ((this.direction === -1 && this.x < 0 - this.width) || (this.direction === 1 && this.x > this.gameWidth + this.width)) {
                    this.active = false;
                }
            }
            draw(ctx) {
                 if (!this.active && !this.isExploding) return;
                let currentSpriteToDraw = null; let spriteType = '';

                if (this.isExploding) {
                    currentSpriteToDraw = this.explosionSprite; spriteType = 'explosion';
                } else if (this.active && this.animationFrames.length > 0 && this.animationFrames[this.currentFrameIndex]) {
                    currentSpriteToDraw = this.animationFrames[this.currentFrameIndex]; spriteType = 'fly';
                }

                if (currentSpriteToDraw && currentSpriteToDraw.complete && currentSpriteToDraw.naturalHeight !== 0) {
                    ctx.drawImage(currentSpriteToDraw, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = this.isExploding ? 'orange' : this.fallbackColor;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    if (spriteType && !this._spriteMissingLogged[spriteType]) {
                        console.warn(`FlyingEnemy:draw - Fallback for ${spriteType} sprite. Details:`, currentSpriteToDraw);
                        this._spriteMissingLogged[spriteType] = true;
                    }
                }
            }
            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
            takeDamage() {
                if (!this.active || this.isExploding) return;
                this.health--;
                if (this.health <= 0) {
                    this.isExploding = true;
                    this.explosionTimer = this.explosionDuration;
                }
            }
        }

        // --- Boss Class ---
        class Boss {
            constructor(gameWidth, gameHeight, player) {
                this.gameWidth = gameWidth; this.gameHeight = gameHeight; this.player = player;
                this.width = 180; this.height = 150;
                this.x = gameWidth; this.y = gameHeight - 10 - this.height;
                this.speed = 1;
                this.health = 9; this.maxHealth = 9;
                this.active = true; this.isEntering = true; this.isDestroyed = false; this.isFiring = false;
                this.fallbackColor = '#800080';
                this.stateTimer = 0; this.idleDuration = 2500; this.firingDuration = 2000;
                this.fireCooldown = 700; this.lastShotTime = 0;
                this.projectiles = [];
                this.sprites = {
                    idle: assetManager.getImage('BOSS1R'), active: assetManager.getImage('BOSS2R'),
                    firing: assetManager.getImage('BOSS3R'), destroyed: assetManager.getImage('BOSS4R'),
                };
                this.currentSprite = this.sprites.idle; this.currentState = 'idle';
                this._spriteMissingLogged = {}; this.explosionTimer = 0; this.explosionDuration = 1000;
            }
            update(effectiveDeltaTime, timeScaleFactor) {
                if (!this.active) return;
                if (this.isDestroyed) {
                    this.explosionTimer -= effectiveDeltaTime;
                    this.projectiles.forEach(p => p.update(effectiveDeltaTime, timeScaleFactor));
                    if (this.explosionTimer <= 0) this.active = false;
                    return;
                }
                if (this.isEntering) {
                    this.x -= this.speed * 0.8 * timeScaleFactor;
                    this.y = this.gameHeight - 10 - this.height;
                    if (this.x <= this.gameWidth - this.width - 50) {
                        this.isEntering = false; this.x = this.gameWidth - this.width - 50;
                        this.stateTimer = this.idleDuration; this.currentState = 'idle';
                        this.currentSprite = this.sprites.idle;
                    } return;
                }
                this.y = this.gameHeight - 10 - this.height;
                this.stateTimer -= effectiveDeltaTime;
                if (this.currentState === 'idle') {
                    this.currentSprite = this.sprites.idle;
                    if (this.stateTimer <= 0) {
                        this.currentState = 'firing'; this.isFiring = true;
                        this.stateTimer = this.firingDuration; this.lastShotTime = 0;
                    }
                } else if (this.currentState === 'firing') {
                    this.currentSprite = this.sprites.firing;
                    this.lastShotTime -= effectiveDeltaTime;
                    if (this.lastShotTime <= 0) { this.shoot(); this.lastShotTime = this.fireCooldown; }
                    if (this.stateTimer <= 0) {
                        this.currentState = 'idle'; this.isFiring = false;
                        this.stateTimer = this.idleDuration; this.currentSprite = this.sprites.idle;
                    }
                }
                this.projectiles.forEach(p => p.update(effectiveDeltaTime, timeScaleFactor));
                this.projectiles = this.projectiles.filter(p => p.active);
            }
            shoot() {
                const projX = this.x + 30; const projY = this.y + this.height * 0.6;
                this.projectiles.push(new Projectile(projX, projY, 'left', this.gameWidth, '#FF6347', 4, 20, 10));
                playLaserSound(0.1, 600, 100, 0.15); // Boss laser sound
            }
            draw(ctx) {
                if (!this.active) return;
                if (this.currentSprite && this.currentSprite.complete && this.currentSprite.naturalHeight !== 0) {
                    ctx.drawImage(this.currentSprite, this.x, this.y, this.width, this.height);
                } else {
                    ctx.fillStyle = this.fallbackColor; ctx.fillRect(this.x, this.y, this.width, this.height);
                    if (this.currentSprite && !this._spriteMissingLogged[this.currentState]) {
                        console.warn(`Boss:draw - Fallback for ${this.currentState} sprite. Sprite details:`, this.currentSprite);
                        this._spriteMissingLogged[this.currentState] = true;
                    }
                }
                if (!this.isDestroyed && !this.isEntering) {
                    const healthBarWidth = this.width * 0.8; const healthBarHeight = 10;
                    const healthBarX = this.x + (this.width - healthBarWidth) / 2;
                    const healthBarY = this.y - healthBarHeight - 8;
                    ctx.fillStyle = '#555'; ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                    const currentHealthWidth = Math.max(0, healthBarWidth * (this.health / this.maxHealth));
                    ctx.fillStyle = '#FF0000'; ctx.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);
                    ctx.strokeStyle = '#333'; ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                }
                this.projectiles.forEach(p => p.draw(ctx));
            }
            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
            takeDamage() {
                if (this.isDestroyed || this.isEntering) return false;
                this.health--; console.log("Boss health:", this.health);
                if (this.health <= 0) {
                    this.health = 0; this.isDestroyed = true; this.currentState = 'destroyed';
                    this.currentSprite = this.sprites.destroyed; this.explosionTimer = this.explosionDuration;
                    this.projectiles = []; return true;
                } return false;
            }
        }

        // --- PickupItem Class ---
        class PickupItem {
            constructor(x, y, sprite, type, width = 48, height = 48) {
                this.x = x - width / 2;
                this.y = y - height / 2;
                this.width = width;
                this.height = height;
                this.sprite = sprite;
                this.type = type;
                this.active = true;
                this.baseY = this.y;
                this.bobAngle = Math.random() * Math.PI * 2;
                this.bobSpeed = 0.05;
                this.bobAmplitude = 5;
            }
            update(effectiveDeltaTime) {
                if (!this.active) return;
                this.bobAngle += this.bobSpeed * (effectiveDeltaTime / NORMAL_FRAME_DURATION_MS);
                this.y = this.baseY + Math.sin(this.bobAngle) * this.bobAmplitude;
            }
            draw(ctx) {
                if (!this.active || !this.sprite || !this.sprite.complete || this.sprite.naturalHeight === 0) return;
                ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height);
            }
            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
        }

        // --- Player Class ---
        class Player {
            constructor(gameWidth, gameHeight) {
                this.gameWidth = gameWidth; this.gameHeight = gameHeight;
                this.width = 60; this.height = 98;
                this.x = 50; this.y = gameHeight - this.height - 10;
                this.playerMovedX = 0;
                this.fallbackColor = '#4CAF50';
                this.speed = 5;
                this.projectiles = [];
                this.velocityY = 0; this.gravity = 0.75;
                this.jumpStrength = -17; this.onGround = true; this.facingDirection = 'right';
                this.isDucking = false; this.isMovingHorizontally = false;
                this.currentWalkFrame = 0; this.walkAnimationTimer = 0; this.walkAnimationDelay = 150;
                this.shootCooldown = 0;
                this.shootCooldownTime = 180; this.plasmaShootCooldownTime = 250;
                this.health = 3; this.isInvincible = false;
                this.invincibilityDuration = 1500; this.invincibilityTimer = 0;
                this._spriteMissingLogged = {};
                this.weaponType = 'default';
                this.spritePlasBulLeft = null; this.spritePlasBulRight = null;

                this.spriteIdleRight = assetManager.getImage('MGSpriteright');
                this.spriteIdleLeft = assetManager.getImage('MGSpriteleft');
                this.spriteWalkRight2 = assetManager.getImage('MGSpriteright2');
                this.spriteWalkLeft2 = assetManager.getImage('MGSpriteleft2');
                this.spriteJumpRight = assetManager.getImage('JumpRight');
                this.spriteJumpLeft = assetManager.getImage('JumpLeft');
                this.spriteDuckRight = assetManager.getImage('DuckRight');
                this.spriteDuckLeft = assetManager.getImage('DuckLeft');
            }

            update(input, effectiveDeltaTime, timeScaleFactor) {
                const oldPlayerX = this.x;
                this.isMovingHorizontally = false;
                this.isDucking = input.isKeyPressed('ArrowDown') && this.onGround;

                if (!this.isDucking) {
                    if (input.isKeyPressed('ArrowLeft')) { this.x -= this.speed * timeScaleFactor; this.facingDirection = 'left'; this.isMovingHorizontally = true; }
                    if (input.isKeyPressed('ArrowRight')) { this.x += this.speed * timeScaleFactor; this.facingDirection = 'right'; this.isMovingHorizontally = true; }
                    if (input.isKeyPressed('ArrowUp') && this.onGround) { this.velocityY = this.jumpStrength; this.onGround = false; }
                }
                this.playerMovedX = this.x - oldPlayerX;

                if (this.isMovingHorizontally && this.onGround && !this.isDucking) {
                    this.walkAnimationTimer += effectiveDeltaTime;
                    if (this.walkAnimationTimer >= this.walkAnimationDelay) { this.currentWalkFrame = 1 - this.currentWalkFrame; this.walkAnimationTimer = 0; }
                } else { this.currentWalkFrame = 0; this.walkAnimationTimer = 0; }

                this.velocityY += this.gravity * timeScaleFactor;
                this.y += this.velocityY * timeScaleFactor;

                const groundLevel = this.gameHeight - this.height - 10;
                if (this.y >= groundLevel) { this.y = groundLevel; this.velocityY = 0; this.onGround = true; }

                this.x = Math.max(0, Math.min(this.x, this.gameWidth - this.width));

                if (this.shootCooldown > 0) this.shootCooldown -= effectiveDeltaTime;
                if (input.consumeShoot() && this.shootCooldown <= 0) {
                    this.shoot();
                    this.shootCooldown = (this.weaponType === 'plasma') ? this.plasmaShootCooldownTime : this.shootCooldownTime;
                }
                this.projectiles.forEach(p => p.update(effectiveDeltaTime, timeScaleFactor));
                this.projectiles = this.projectiles.filter(p => p.active);

                if (this.isInvincible) { this.invincibilityTimer -= effectiveDeltaTime; if (this.invincibilityTimer <= 0) this.isInvincible = false; }
            }

            updateVisualsOnly(effectiveDeltaTime) {
                this.currentWalkFrame = 0;
                this.walkAnimationTimer = 0;
            }

            shoot() {
                let projSpeed = 9;
                let projWidth = 10; let projHeight = 5;
                let projColor = '#FFEB3B'; let projSprite = null;

                if (this.weaponType === 'plasma') {
                    if (!this.spritePlasBulLeft) this.spritePlasBulLeft = assetManager.getImage('plasBulLeft');
                    if (!this.spritePlasBulRight) this.spritePlasBulRight = assetManager.getImage('plasBulRight');
                    projSprite = (this.facingDirection === 'right') ? this.spritePlasBulRight : this.spritePlasBulLeft;
                    projColor = null;
                    if (projSprite && projSprite.complete && projSprite.naturalHeight !== 0) {
                        projWidth = projSprite.width / 4; projHeight = projSprite.height / 4;
                    } else {
                        projWidth = 20; projHeight = 10; projColor = '#00FFFF';
                        console.warn("Player.shoot: Plasma sprite not loaded, using fallback dimensions/color.");
                    }
                    projSpeed = 7;
                    playLaserSound(0.12, 1200, 300, 0.08); // Player plasma sound
                } else {
                    playLaserSound(); // Default player laser sound
                }

                const projX = this.facingDirection === 'right' ? this.x + this.width : this.x - projWidth;
                const projY = this.y + this.height / 2 - projHeight / 2;
                this.projectiles.push(new Projectile(projX, projY, this.facingDirection, this.gameWidth, projColor, projSpeed, projWidth, projHeight, projSprite));
            }
            draw(ctx) {
                let currentSprite = null; let spriteKey = '';
                if (this.isDucking) { spriteKey = this.facingDirection === 'right'?'DuckRight':'DuckLeft'; currentSprite = this.facingDirection === 'right'?this.spriteDuckRight:this.spriteDuckLeft;
                } else if (!this.onGround) { spriteKey = this.facingDirection === 'right'?'JumpRight':'JumpLeft'; currentSprite = this.facingDirection === 'right'?this.spriteJumpRight:this.spriteJumpLeft;
                } else { if (this.isMovingHorizontally) { if (this.facingDirection === 'right') { spriteKey = this.currentWalkFrame===0?'MGSpriteright':'MGSpriteright2'; currentSprite = this.currentWalkFrame===0?this.spriteIdleRight:this.spriteWalkRight2; } else { spriteKey = this.currentWalkFrame===0?'MGSpriteleft':'MGSpriteleft2'; currentSprite = this.currentWalkFrame===0?this.spriteIdleLeft:this.spriteWalkLeft2; } } else { spriteKey = this.facingDirection === 'right'?'MGSpriteright':'MGSpriteleft'; currentSprite = this.facingDirection === 'right'?this.spriteIdleRight:this.spriteIdleLeft; } }

                if (this.isInvincible) ctx.globalAlpha = (Math.floor(Date.now()/100)%2===0)?0.6:1.0;
                let drewSprite = false;
                if (currentSprite && currentSprite.complete && currentSprite.naturalHeight !== 0) {
                    try { ctx.drawImage(currentSprite, this.x, this.y, this.width, this.height); drewSprite = true; }
                    catch (e) { console.error("Player:draw Error drawing player sprite:", e, currentSprite); }
                }
                if (!drewSprite) {
                    ctx.fillStyle = this.fallbackColor;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    if (spriteKey && !this._spriteMissingLogged[spriteKey]) {
                        console.warn(`Player:draw Fallback for player sprite key "${spriteKey}"`, currentSprite);
                        this._spriteMissingLogged[spriteKey] = true;
                    }
                }
                ctx.globalAlpha = 1.0;
                this.projectiles.forEach(p => p.draw(ctx));
            }
            getRect() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
            takeDamage() {
                if (this.isInvincible) return false;
                this.health--;
                if (this.health > 0) {
                    this.isInvincible = true;
                    this.invincibilityTimer = this.invincibilityDuration;
                }
                return true;
            }
        }

        // --- Game Class ---
        class Game {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                if (!this.canvas || !this.ctx) {
                    alert("Error: Canvas not supported or found. Game cannot start.");
                    throw new Error("Canvas initialization failed");
                }
                this.canvas.width = 960; this.canvas.height = 540;
                this.inputHandler = new InputHandler();
                this.player = null; this.enemies = []; this.score = 0; this.lastTime = 0;
                this.animationFrameId = null;
                this.enemySpawnTimer = 0; this.enemySpawnInterval = 2500;
                this.gameLoop = this.gameLoop.bind(this);
                this.backgroundSprite = null; this.foliageSprite1 = null; this.foliageSprite2 = null;
                this.foliageX = 0; this.foliageScrollSpeedFactor = 0.3;
                this.gameState = 'LOADING';
                this.getReadySprite = null; this.goSprite = null;
                this.gameOverSprite = null; this.playAgainButtonSprite = null;
                this.preGameMessageTimer = 0; this.getReadyDuration = 2000; this.goDuration = 1000;
                this.playAgainButtonRect = null;
                this.canvas.addEventListener('click', this.handleCanvasClick.bind(this));

                this.boss = null;
                this.bossSpawnScoreInterval = 1000; this.nextBossSpawnScore = 500;

                this.heartSpriteFull = null; this.heartSpriteDamaged = null; this.heartSpriteCritical = null;
                this.heartSpriteDisplayWidth = 68; this.heartSpriteDisplayHeight = 68;

                this.pickupItems = []; this.plasBoxSprite = null;
                this.plasBoxDisplayWidth = 70; this.plasBoxDisplayHeight = 70;

                this.backgroundMusic = null;

                this.gameSpeedMultiplier = 1.0;
                this.turboSpeedMultiplierValue = 1.75;
                this.setupSpeedControls();

                // Attempt to initialize AudioContext on first click anywhere if not already done by keydown
                // Do this gently, so it doesn't block game start if user doesn't click.
                // Sounds will attempt to initialize/resume context when first played.
                document.body.addEventListener('click', () => getAudioContext(), { once: true });
            }

            setupSpeedControls() {
                const speedRadios = document.querySelectorAll('input[name="speedSetting"]');
                speedRadios.forEach(radio => {
                    radio.addEventListener('change', (event) => {
                        getAudioContext(); // Ensure AudioContext is active
                        if (event.target.value === 'turbo') {
                            this.gameSpeedMultiplier = this.turboSpeedMultiplierValue;
                            console.log("Game speed: TURBO (x" + this.gameSpeedMultiplier + ")");
                        } else {
                            this.gameSpeedMultiplier = 1.0;
                            console.log("Game speed: NORMAL (x" + this.gameSpeedMultiplier + ")");
                        }
                    });
                });
            }

            handleCanvasClick(event) {
                getAudioContext(); // Ensure AudioContext is active for sound

                if (this.gameState !== 'GAME_OVER' || !this.playAgainButtonRect) return;
                const rect = this.canvas.getBoundingClientRect();
                const clickX = event.clientX - rect.left; const clickY = event.clientY - rect.top;
                if (clickX >= this.playAgainButtonRect.x && clickX <= this.playAgainButtonRect.x + this.playAgainButtonRect.width &&
                    clickY >= this.playAgainButtonRect.y && clickY <= this.playAgainButtonRect.y + this.playAgainButtonRect.height) {
                    playClickSound(); // Play click sound for button
                    this.resetGame();
                }
            }

            resetGame() {
                this.gameState = 'PRE_GAME_GET_READY';
                this.preGameMessageTimer = this.getReadyDuration;
                this.score = 0; this.enemies = []; this.enemySpawnTimer = 0; this.enemySpawnInterval = 2500;
                this.playAgainButtonRect = null; this.canvas.classList.remove('clickable');
                if (this.player) {
                    this.player.x = 50; this.player.y = this.canvas.height - this.player.height - 10;
                    this.player.velocityY = 0; this.player.onGround = true; this.player.facingDirection = 'right';
                    this.player.health = 3; this.player.projectiles = []; this.player.isInvincible = false;
                    this.player.invincibilityTimer = 0; this.player.isMovingHorizontally = false; this.player.currentWalkFrame = 0;
                    this.player.weaponType = 'default';
                }
                this.boss = null; this.nextBossSpawnScore = 500; this.pickupItems = [];
                console.log("Game: Game reset. Next boss at score:", this.nextBossSpawnScore);

                if (this.backgroundMusic) {
                    this.backgroundMusic.currentTime = 0;
                    const playPromise = this.backgroundMusic.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.warn("Background music autoplay was prevented.", error);
                        });
                    }
                }
            }

            spawnEnemy() {
                let newEnemy = null; const spawnFlyingChance = 0.35;
                if (Math.random() < spawnFlyingChance) {
                    const enemyWidth = 48; const enemyHeight = 48;
                    const spawnY = this.canvas.height * 0.3 + Math.random() * (this.canvas.height * 0.33);
                    let spawnX = (Math.random() < 0.5) ? (0 - (Math.random() * 50 + enemyWidth)) : (this.canvas.width + Math.random() * 50);
                    newEnemy = new FlyingEnemy(spawnX, spawnY, this.canvas.width);
                } else {
                    const enemyWidth = 50; const enemyHeight = 75;
                    const enemyY = this.canvas.height - 10 - enemyHeight;
                    let spawnX = (Math.random() < 0.5) ? (0 - (Math.random() * 50 + enemyWidth)) : (this.canvas.width + Math.random() * 50);
                    newEnemy = new Enemy(spawnX, enemyY, this.canvas.width);
                }
                if (newEnemy) this.enemies.push(newEnemy);
            }

            spawnBoss() {
                if (!this.boss && this.player) {
                    console.log(`Game: Spawning Boss! Current score: ${this.score}, Next boss score: ${this.nextBossSpawnScore}`);
                    this.boss = new Boss(this.canvas.width, this.canvas.height, this.player);
                    this.enemies = [];
                }
            }

            update(effectiveDeltaTime, timeScaleFactor) {
                if (!this.player && this.gameState !== 'LOADING' && this.gameState !== 'GAME_OVER') {
                    console.warn("Game: Player not initialized during an active game state:", this.gameState); return;
                }
                if (this.gameState === 'GAME_OVER' && this.playAgainButtonRect) {
                    this.canvas.classList.add('clickable');
                } else {
                    this.canvas.classList.remove('clickable');
                }

                switch (this.gameState) {
                    case 'PRE_GAME_GET_READY':
                        this.preGameMessageTimer -= effectiveDeltaTime;
                        if (this.preGameMessageTimer <= 0) { this.gameState = 'PRE_GAME_GO'; this.preGameMessageTimer = this.goDuration; }
                        if (this.player) this.player.updateVisualsOnly(effectiveDeltaTime);
                        return;
                    case 'PRE_GAME_GO':
                        this.preGameMessageTimer -= effectiveDeltaTime;
                        if (this.preGameMessageTimer <= 0) { this.gameState = 'RUNNING'; }
                        if (this.player) this.player.updateVisualsOnly(effectiveDeltaTime);
                        return;
                    case 'GAME_OVER': return;
                    case 'RUNNING': break;
                    default: return;
                }

                if (this.score >= this.nextBossSpawnScore && !this.boss) {
                    this.spawnBoss();
                }

                this.player.update(this.inputHandler, effectiveDeltaTime, timeScaleFactor);
                let bossDefeatedThisFrame = false;

                if (this.boss && this.boss.active) {
                    this.boss.update(effectiveDeltaTime, timeScaleFactor);
                    this.player.projectiles.forEach(proj => {
                        if (proj.active && AABBCollision(proj.getRect(), this.boss.getRect()) && !this.boss.isDestroyed && !this.boss.isEntering) {
                            proj.active = false; let regularScoreForHit = 25; this.score += regularScoreForHit;
                            if (this.boss.takeDamage()) {
                                this.score += (1000 - regularScoreForHit); bossDefeatedThisFrame = true;
                            }
                        }
                    });
                    if (!this.player.isInvincible) {
                        this.boss.projectiles.forEach(bossProj => {
                            if (bossProj.active && AABBCollision(bossProj.getRect(), this.player.getRect())) {
                                bossProj.active = false;
                                if (this.player.takeDamage() && this.player.health <= 0) { this.gameOver(); }
                            }
                        });
                    }
                    if (!this.player.isInvincible && AABBCollision(this.player.getRect(), this.boss.getRect()) && !this.boss.isDestroyed && !this.boss.isEntering) {
                        if (this.player.takeDamage() && this.player.health <= 0) { this.gameOver(); }
                    }

                    if (bossDefeatedThisFrame) {
                        this.nextBossSpawnScore = this.score + this.bossSpawnScoreInterval;
                        console.log("Boss defeated! Next boss will spawn at score:", this.nextBossSpawnScore);
                        if (this.plasBoxSprite) {
                            const pickupX = this.boss.x + this.boss.width / 2;
                            const pickupY = this.boss.y + this.boss.height / 2;
                            this.pickupItems.push(new PickupItem(pickupX, pickupY, this.plasBoxSprite, 'plasma_weapon', this.plasBoxDisplayWidth, this.plasBoxDisplayHeight));
                            console.log("Plasma Box spawned at", pickupX.toFixed(0), pickupY.toFixed(0));
                        } else {
                            console.warn("Game.update: plasBoxSprite not loaded, cannot spawn pickup.");
                        }
                    }
                } else {
                    this.enemies.forEach(enemy => enemy.update(effectiveDeltaTime, timeScaleFactor));
                    this.player.projectiles.forEach(proj => {
                        this.enemies.forEach(enemy => {
                            if (proj.active && enemy.active && !enemy.isExploding && AABBCollision(proj.getRect(), enemy.getRect())) {
                                proj.active = false; enemy.takeDamage(); this.score += (enemy instanceof FlyingEnemy ? 75 : 50);
                            }
                        });
                    });
                    this.enemies.forEach(enemy => {
                        if (enemy.active && !enemy.isExploding && AABBCollision(this.player.getRect(), enemy.getRect())) {
                            if (this.player.takeDamage() && this.player.health <= 0) { this.gameOver(); }
                        }
                    });

                    if (!this.boss) {
                        this.enemySpawnTimer += effectiveDeltaTime;
                        if (this.enemySpawnTimer >= this.enemySpawnInterval) {
                            if (this.enemies.length < 8) this.spawnEnemy();
                            this.enemySpawnTimer = 0;
                            if (this.enemySpawnInterval > 800) this.enemySpawnInterval -= 20;
                        }
                    }
                }

                for (let i = this.pickupItems.length - 1; i >= 0; i--) {
                    const pickup = this.pickupItems[i];
                    pickup.update(effectiveDeltaTime);
                    if (!pickup.active) {
                        this.pickupItems.splice(i, 1); continue;
                    }
                    if (this.player && AABBCollision(this.player.getRect(), pickup.getRect())) {
                        if (pickup.type === 'plasma_weapon') {
                            this.player.weaponType = 'plasma';
                            console.log("Player picked up Plasma Weapon!");
                        }
                        pickup.active = false;
                    }
                }

                this.player.projectiles = this.player.projectiles.filter(p => p.active);
                if (this.boss) this.boss.projectiles = this.boss.projectiles.filter(p => p.active);
                this.enemies = this.enemies.filter(e => e.active);

                if (this.boss && !this.boss.active && !bossDefeatedThisFrame) {
                    this.boss = null;
                }

                if (this.player.playerMovedX !== 0 && this.foliageSprite1 && this.foliageSprite2) {
                    this.foliageX -= this.player.playerMovedX * this.foliageScrollSpeedFactor;
                    const combinedFoliageWidth = (this.foliageSprite1.width || 0) + (this.foliageSprite2.width || 0);
                    if (combinedFoliageWidth > 0) {
                        this.foliageX %= combinedFoliageWidth;
                    }
                }
                this.player.playerMovedX = 0;
            }

            drawPlayerHealth() {
                if (!this.player) return;
                let currentHeartSprite = null;
                if (this.player.health === 3) { currentHeartSprite = this.heartSpriteFull;
                } else if (this.player.health === 2) { currentHeartSprite = this.heartSpriteDamaged;
                } else if (this.player.health === 1) { currentHeartSprite = this.heartSpriteCritical; }

                if (currentHeartSprite && currentHeartSprite.complete && currentHeartSprite.naturalHeight !== 0) {
                    const heartX = this.canvas.width - this.heartSpriteDisplayWidth - 20;
                    const heartY = 10;
                    this.ctx.drawImage(currentHeartSprite, heartX, heartY, this.heartSpriteDisplayWidth, this.heartSpriteDisplayHeight);
                } else if (this.player.health > 0) {
                    this.ctx.fillStyle = 'white'; this.ctx.font = '18px "Press Start 2P"';
                    this.ctx.textAlign = 'right'; this.ctx.fillText(`HP: ${this.player.health}`, this.canvas.width - 20, 30);
                    if (!currentHeartSprite) { console.warn(`Game.drawPlayerHealth: No heart sprite for health ${this.player.health}.`);
                    } else { console.warn(`Game.drawPlayerHealth: Heart sprite for health ${this.player.health} (${currentHeartSprite.src}) not loaded.`); }
                }
            }

            draw() {
                if (this.backgroundSprite && this.backgroundSprite.complete && this.backgroundSprite.naturalHeight !== 0) {
                    this.ctx.drawImage(this.backgroundSprite, 0, 0, this.canvas.width, this.canvas.height);
                } else { this.ctx.fillStyle = '#2c3e50'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); }

                const f1W = this.foliageSprite1 ? this.foliageSprite1.width : 0;
                const f2W = this.foliageSprite2 ? this.foliageSprite2.width : 0;
                const combinedFoliageWidth = f1W + f2W;
                if (this.foliageSprite1 && this.foliageSprite1.complete && this.foliageSprite1.naturalHeight !== 0 &&
                    this.foliageSprite2 && this.foliageSprite2.complete && this.foliageSprite2.naturalHeight !== 0 &&
                    combinedFoliageWidth > 0) {
                    let startX = this.foliageX % combinedFoliageWidth;
                    if (startX > 0) startX -= combinedFoliageWidth;
                    for (let currentX = startX; currentX < this.canvas.width; currentX += combinedFoliageWidth) {
                        if (f1W > 0) this.ctx.drawImage(this.foliageSprite1, currentX, 0, f1W, this.canvas.height);
                        if (f2W > 0) this.ctx.drawImage(this.foliageSprite2, currentX + f1W, 0, f2W, this.canvas.height);
                    }
                }
                this.ctx.fillStyle = '#7f8c8d'; this.ctx.fillRect(0, this.canvas.height - 10, this.canvas.width, 10);
                this.pickupItems.forEach(pickup => pickup.draw(this.ctx));
                if (this.player) { this.player.draw(this.ctx);
                } else if (this.gameState !== 'LOADING' && this.gameState !== 'GAME_OVER') {
                    this.ctx.fillStyle='white'; this.ctx.font='20px "Press Start 2P"';
                    this.ctx.textAlign='center'; this.ctx.fillText('Initializing Player...', this.canvas.width/2, this.canvas.height/2);
                }

                switch (this.gameState) {
                    case 'PRE_GAME_GET_READY':
                        if(this.getReadySprite && this.getReadySprite.complete && this.getReadySprite.naturalHeight!==0){
                            const nW=this.getReadySprite.width*0.7; const nH=this.getReadySprite.height*0.7;
                            const x=(this.canvas.width-nW)/2; const y=(this.canvas.height-nH)/2;
                            this.ctx.drawImage(this.getReadySprite,x,y,nW,nH);
                        } break;
                    case 'PRE_GAME_GO':
                        if(this.goSprite && this.goSprite.complete && this.goSprite.naturalHeight!==0){
                            const nW=this.goSprite.width*0.7; const nH=this.goSprite.height*0.7;
                            const x=(this.canvas.width-nW)/2; const y=(this.canvas.height-nH)/2;
                            this.ctx.drawImage(this.goSprite,x,y,nW,nH);
                        } break;
                    case 'RUNNING':
                        this.enemies.forEach(enemy=>enemy.draw(this.ctx));
                        if(this.boss && this.boss.active) { this.boss.draw(this.ctx); }
                        this.ctx.fillStyle='white'; this.ctx.font='20px "Press Start 2P"';
                        this.ctx.textAlign='left'; this.ctx.fillText(`Score: ${this.score}`,20,30);
                        this.drawPlayerHealth();
                        break;
                    case 'GAME_OVER': this.drawGameOverScreen(); break;
                }
            }

            drawGameOverScreen() {
                this.ctx.fillStyle='rgba(0,0,0,0.85)'; this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height);
                const titleScale=0.25; const scoreFontSize=18; const buttonScale=0.15;
                const vertPaddingTitle=20; const vertPaddingScore=15;
                let currentY=this.canvas.height*0.12;

                if(this.gameOverSprite && this.gameOverSprite.complete && this.gameOverSprite.naturalHeight!==0){
                    const oW=this.gameOverSprite.width; const oH=this.gameOverSprite.height;
                    const nW=oW*titleScale; const nH=oH*titleScale;
                    const sX=(this.canvas.width-nW)/2;
                    this.ctx.drawImage(this.gameOverSprite,sX,currentY,nW,nH);
                    currentY+=nH+vertPaddingTitle;
                } else {
                    this.ctx.font='30px "Press Start 2P"'; this.ctx.fillStyle='#E74C3C'; this.ctx.textAlign='center';
                    const tM=this.ctx.measureText('GAME OVER');
                    const tH=(tM.actualBoundingBoxAscent+tM.actualBoundingBoxDescent)||30;
                    this.ctx.fillText('GAME OVER',this.canvas.width/2,currentY+tH/2);
                    currentY+=tH+vertPaddingTitle;
                }
                this.ctx.font=`${scoreFontSize}px "Press Start 2P"`; this.ctx.fillStyle='white'; this.ctx.textAlign='center';
                const scoreText=`Final Score: ${this.score}`; const scoreTextHeight=scoreFontSize*1.2;
                this.ctx.fillText(scoreText,this.canvas.width/2,currentY+scoreTextHeight/2);
                currentY+=scoreTextHeight+vertPaddingScore;

                if(this.playAgainButtonSprite && this.playAgainButtonSprite.complete && this.playAgainButtonSprite.naturalHeight!==0){
                    const bOW=this.playAgainButtonSprite.width; const bOH=this.playAgainButtonSprite.height;
                    const nBW=bOW*buttonScale; const nBH=bOH*buttonScale;
                    const bX=(this.canvas.width-nBW)/2; const bY=currentY;
                    this.ctx.drawImage(this.playAgainButtonSprite,bX,bY,nBW,nBH);
                    this.playAgainButtonRect={x:bX,y:bY,width:nBW,height:nBH};
                } else {
                    this.ctx.font='16px "Press Start 2P"';
                    this.ctx.fillText('Refresh to Play Again',this.canvas.width/2,currentY+(16*0.6));
                    this.playAgainButtonRect=null;
                }
            }

            gameOver() { this.gameState = 'GAME_OVER'; console.log("Game: Game Over."); }

            gameLoop(timestamp) {
                const actualDeltaTime = (timestamp - (this.lastTime || timestamp)) || NORMAL_FRAME_DURATION_MS;
                this.lastTime = timestamp;

                const effectiveDeltaTime = actualDeltaTime * this.gameSpeedMultiplier;
                const timeScaleFactor = effectiveDeltaTime / NORMAL_FRAME_DURATION_MS;

                this.update(effectiveDeltaTime, timeScaleFactor);
                this.draw();
                this.animationFrameId = requestAnimationFrame(this.gameLoop);
            }

            async initAndStart() {
                console.log("Game: Starting asset loading phase."); this.gameState = 'LOADING';
                assetManager.loadImage('MGSpriteleft', 'MGSpriteleft.png'); assetManager.loadImage('MGSpriteright', 'MGSpriteright.png');
                assetManager.loadImage('MGSpriteleft2', 'MGSpriteleft2.png'); assetManager.loadImage('MGSpriteright2', 'MGSpriteright2.png');
                assetManager.loadImage('JumpLeft', 'JumpLeft.png'); assetManager.loadImage('JumpRight', 'JumpRight.png');
                assetManager.loadImage('DuckLeft', 'DuckLeft.png'); assetManager.loadImage('DuckRight', 'DuckRight.png');
                assetManager.loadImage('leftEnemyWalk1', 'leftenemy1.png'); assetManager.loadImage('leftEnemyWalk2', 'leftenemy2.png');
                assetManager.loadImage('leftEnemyExplosion', 'leftenemy3.png'); assetManager.loadImage('rightEnemyWalk1', 'rightenemy1.png');
                assetManager.loadImage('rightEnemyWalk2', 'rightenemy2.png'); assetManager.loadImage('rightEnemyExplosion', 'rightenemy3.png');
                assetManager.loadImage('Robo1', 'Robo1.png'); assetManager.loadImage('Robo2', 'Robo2.png');
                assetManager.loadImage('Robo3', 'Robo3.png'); assetManager.loadImage('Robo4', 'Robo4.png');
                assetManager.loadImage('Robo1 copy', 'Robo1 copy.png'); assetManager.loadImage('Robo2 copy', 'Robo2 copy.png');
                assetManager.loadImage('Robo3 copy', 'Robo3 copy.png'); assetManager.loadImage('Robo4 copy', 'Robo4 copy.png');
                assetManager.loadImage('RoboPOP', 'RoboPOP.png');
                assetManager.loadImage('background', 'SettingSun.png'); assetManager.loadImage('foliage1', 'foliage1.png'); assetManager.loadImage('foliage2', 'foliage2.png');
                assetManager.loadImage('getReady', 'GETREADY.png'); assetManager.loadImage('go', 'GO.png');
                assetManager.loadImage('gameOverTitle', 'GAMEOVER.png'); assetManager.loadImage('playAgainButton', 'PLAYAGAIN.png');
                assetManager.loadImage('BOSS1R', 'BOSS1R.png'); assetManager.loadImage('BOSS2R', 'BOSS2R.png');
                assetManager.loadImage('BOSS3R', 'BOSS3R.png'); assetManager.loadImage('BOSS4R', 'BOSS4R.png');
                assetManager.loadImage('heartFull', 'HEARTONE.png'); assetManager.loadImage('heartDamaged', 'HEARTTWO.png');
                assetManager.loadImage('heartCritical', 'HEARTTHREE.png');
                assetManager.loadImage('plasBox', 'PlasBox.png'); assetManager.loadImage('plasBulLeft', 'PlasBul.png');
                assetManager.loadImage('plasBulRight', 'PlasBulRight.png');

                try {
                    await assetManager.loadAll(); console.log("Game: Asset loading complete.");
                    this.backgroundSprite = assetManager.getImage('background');
                    this.foliageSprite1 = assetManager.getImage('foliage1');
                    this.foliageSprite2 = assetManager.getImage('foliage2');
                    this.getReadySprite = assetManager.getImage('getReady');
                    this.goSprite = assetManager.getImage('go');
                    this.gameOverSprite = assetManager.getImage('gameOverTitle');
                    this.playAgainButtonSprite = assetManager.getImage('playAgainButton');
                    this.heartSpriteFull = assetManager.getImage('heartFull');
                    this.heartSpriteDamaged = assetManager.getImage('heartDamaged');
                    this.heartSpriteCritical = assetManager.getImage('heartCritical');
                    this.plasBoxSprite = assetManager.getImage('plasBox');
                    if (!this.backgroundSprite) console.warn("Game: Background sprite 'SettingSun.png' not loaded!");

                    try {
                        this.backgroundMusic = new Audio('melancholic-classical-music-longing-heart-326205.mp3');
                        this.backgroundMusic.loop = true; this.backgroundMusic.volume = 0.3;
                        console.log("Game: Background music object created.");
                    } catch (e) {
                        console.error("Game: Error creating Audio object for background music.", e);
                        this.backgroundMusic = null;
                    }

                } catch (err) {
                    console.error("Game: Critical error loading assets:", err);
                    this.gameState = 'ERROR_LOADING'; return;
                }

                this.player = new Player(this.canvas.width, this.canvas.height); console.log("Game: Player initialized.");
                this.resetGame();
                if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
                this.lastTime = 0;
                console.log("Game: Starting game loop.");
                this.animationFrameId = requestAnimationFrame(this.gameLoop);
            }
        }

        // --- Initialize Game ---
        window.addEventListener('DOMContentLoaded', () => {
            console.log("Script: DOMContentLoaded event fired.");
            try {
                const game = new Game('gameCanvas');
                console.log("Script: Game instance created. Calling initAndStart...");
                game.initAndStart().catch(err => {
                    console.error("Script: FATAL - Failed to initialize and start game (async error):", err);
                    const loadingMessageEl = document.getElementById('loadingMessage');
                    if (loadingMessageEl) loadingMessageEl.textContent = "FATAL ERROR starting game. Check console.";
                    else alert("FATAL ERROR starting game. Check console.");
                });
            } catch (e) {
                console.error("Script: FATAL - Error creating Game instance (sync error):", e);
                const loadingMessageEl = document.getElementById('loadingMessage');
                if (loadingMessageEl) loadingMessageEl.textContent = "Critical error creating game instance. Check console.";
                else alert("Critical error: Game could not be created. Check console.");
            }
         });
        console.log("Script: Initial setup execution finished.");
    </script>
</body>
</html>
